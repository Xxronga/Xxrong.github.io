<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL读书笔记</title>
    <link href="/2023/11/05/sql-mosh/"/>
    <url>/2023/11/05/sql-mosh/</url>
    
    <content type="html"><![CDATA[<p> MySQL-reading notes</p><span id="more"></span><p><a href="https://www.bilibili.com/video/BV1UE41147KC/?p=8&spm_id_from=pageDriver&vd_source=50339af4080e63c88cca799f0870a5a1">https://www.bilibili.com/video/BV1UE41147KC/?p=8&amp;spm_id_from=pageDriver&amp;vd_source=50339af4080e63c88cca799f0870a5a1</a></p><p><a href="https://zhuanlan.zhihu.com/p/222865842">https://zhuanlan.zhihu.com/p/222865842</a></p><p>💛<a href="https://zhuanlan.zhihu.com/p/222932740">https://zhuanlan.zhihu.com/p/222932740</a></p><hr><p>数据库是一个以可轻易获取形式来存储的数据的集合</p><p>为了管理数据，我们使用一种叫做数据库管理系统 或DBMS 的软件应用。</p><p><img src="/2023/11/05/sql-mosh/image-20231105205930980.png" alt="image-20231105205930980"></p><p>DBMS被归为两大类：关系型和非关系型（NoSQL）</p><ul><li><p>在<u>关系型数据库</u>中，我们把数据存储在利用关系互相链接的表中。</p><p><img src="/2023/11/05/sql-mosh/image-20231105205940165.png" alt="image-20231105205940165"></p></li><li><p>在<u>非关系型数据库</u>中，我们没有表或者关系。（非关系型DBMS无法读取SQL语言）</p></li></ul><h1 id="数据概要"><a href="#数据概要" class="headerlink" title="数据概要"></a>数据概要</h1><p>课程一共用到四个数据库，分别是</p><ol><li>sql_invoicing（发票数据库）</li><li>sql_store（商店数据库）</li><li>sql_inventory（存货数据库）</li><li>sql_hr（人力资源数据库）</li></ol><p>其中，主要是前两个数据库用的比较多，后两个数据库只是在特定主题下讲过一两次，结构简单。</p><h2 id="1-sql-store"><a href="#1-sql-store" class="headerlink" title="1. sql_store"></a>1. sql_store</h2><h1 id="第一部分：基础–增删查改"><a href="#第一部分：基础–增删查改" class="headerlink" title="第一部分：基础–增删查改"></a>第一部分：基础–增删查改</h1><h2 id="【第一章】预备工作"><a href="#【第一章】预备工作" class="headerlink" title="【第一章】预备工作"></a>【第一章】预备工作</h2><h2 id="【第二章】在单一表格中检索数据"><a href="#【第二章】在单一表格中检索数据" class="headerlink" title="【第二章】在单一表格中检索数据"></a>【第二章】在单一表格中检索数据</h2><h3 id="1-选择语句"><a href="#1-选择语句" class="headerlink" title="1.选择语句"></a>1.选择语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-operator">/</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span> <span class="hljs-comment">-- 纵向筛选列，甚至可以是常数</span><br><span class="hljs-keyword">FROM</span> customers <span class="hljs-comment">-- 选择表</span><br><span class="hljs-comment">-- WHERE customer_id=1 -- 横向删选表</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> first_name <span class="hljs-comment">-- 排序</span><br><br><span class="hljs-comment">-- 单行注释</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">多行注释</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="2-选择子句"><a href="#2-选择子句" class="headerlink" title="2. 选择子句"></a>2. 选择子句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><span class="hljs-keyword">SELECT</span> <br><span class="hljs-keyword">DISTINCT</span> last_name,<br>first_name,<br>points.<br>(points <span class="hljs-operator">+</span> <span class="hljs-number">70</span>) <span class="hljs-operator">%</span> <span class="hljs-number">100</span> <span class="hljs-keyword">AS</span> discount_factor<span class="hljs-operator">/</span><span class="hljs-string">&#x27;discount factor&#x27;</span><br><span class="hljs-keyword">FROM</span> customers<br></code></pre></td></tr></table></figure><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- return all the products</span><br><span class="hljs-comment">-- name </span><br><span class="hljs-comment">-- unit price</span><br><span class="hljs-comment">-- new price (unit price * 1.1)</span><br><br><span class="hljs-keyword">SELECT</span><br>name,<br>unit_price,<br>unit_price <span class="hljs-operator">*</span> <span class="hljs-number">1.1</span> <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;new price&#x27;</span><br><span class="hljs-keyword">FROM</span> products<br></code></pre></td></tr></table></figure><h3 id="3-where-字句"><a href="#3-where-字句" class="headerlink" title="3. where 字句"></a>3. where 字句</h3><blockquote><p>筛选数据;</p><p>比较运算符 &gt;, &lt;, &#x3D;, &lt;&#x3D;, &gt;&#x3D;, !&#x3D;, &#x2F;, &lt;&gt;</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> customers<br><span class="hljs-keyword">WHERE</span> points <span class="hljs-operator">&gt;</span> <span class="hljs-number">3000</span><br><span class="hljs-operator">/</span> <span class="hljs-keyword">WHERE</span> state <span class="hljs-operator">!=</span> <span class="hljs-string">&#x27;va&#x27;</span><br></code></pre></td></tr></table></figure><p>也可以对日期或文本进行比较运算，注意SQL里的日期要用引号包裹</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WHERE</span> birth_date <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;1990-01-01&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="4-AND-OR-NOT运算符"><a href="#4-AND-OR-NOT运算符" class="headerlink" title="4. AND, OR, NOT运算符"></a>4. AND, OR, NOT运算符</h3><p>用逻辑运算符and，or，not进行多重条件筛选执行优先级：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> customers<br><span class="hljs-keyword">WHERE</span> birth_date <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;1990-01-01&#x27;</span> <span class="hljs-keyword">AND</span> points <span class="hljs-operator">&gt;</span> <span class="hljs-number">1000</span><br><span class="hljs-operator">/</span><span class="hljs-keyword">WHERE</span> birth_date <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;1990-01-01&#x27;</span> <span class="hljs-keyword">OR</span> <br>      points <span class="hljs-operator">&gt;</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">AND</span> state <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;VA&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>AND优先级高于OR，但最好加括号，更清晰</strong></p><p>NOT用法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> (birth_date <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;1990-01-01&#x27;</span> <span class="hljs-keyword">OR</span> points <span class="hljs-operator">&gt;</span> <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><p>去括号等价于</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WHERE</span> birth_date <span class="hljs-operator">&lt;=</span> <span class="hljs-string">&#x27;1990-01-01&#x27;</span> <span class="hljs-keyword">AND</span> points <span class="hljs-operator">&lt;=</span> <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><h3 id="5-IN-运算符"><a href="#5-IN-运算符" class="headerlink" title="5. IN 运算符"></a>5. IN 运算符</h3><p>用IN运算符将某一属性<strong>与多个值（一系列值）进行比较</strong><br>实质是多重相等比较运算条件的简化</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> customers<br><span class="hljs-keyword">WHERE</span> state <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;va&#x27;</span> <span class="hljs-keyword">OR</span> state <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;fl&#x27;</span> <span class="hljs-keyword">OR</span> state <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;ga&#x27;</span><br></code></pre></td></tr></table></figure><p>不能 <code>state = &#39;va&#39; OR &#39;fl&#39; OR &#39;ga&#39;</code> 因为数学和比较运算优先于逻辑运算，加括号 <code>state = (&#39;va&#39; OR &#39;fl&#39; OR &#39;ga&#39;)</code> 也不行，逻辑运算符只能链接布林值。</p><p>用 IN 操作符简化该条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WHERE</span> state <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;va&#x27;</span>, <span class="hljs-string">&#x27;fl&#x27;</span>, <span class="hljs-string">&#x27;ga&#x27;</span>)<br></code></pre></td></tr></table></figure><p>可加NOT</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WHERE</span> state <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;va&#x27;</span>, <span class="hljs-string">&#x27;fl&#x27;</span>, <span class="hljs-string">&#x27;ga&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="6-BETWEEN运算符"><a href="#6-BETWEEN运算符" class="headerlink" title="6. BETWEEN运算符"></a>6. BETWEEN运算符</h3><p>用于表达<strong>范围</strong>型条件</p><blockquote><ul><li>用AND而非括号</li><li><strong>闭区间，包含两端点</strong></li><li>也可用于日期，毕竟日期本质也是数值，日期也有大小（早晚），可比较运算</li><li>同 IN 一样，BETWEEN 本质也是一种特定的 多重比较运算条件 的简化</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> customers<br><span class="hljs-keyword">where</span> points <span class="hljs-operator">&gt;=</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">and</span> points <span class="hljs-operator">&lt;=</span> <span class="hljs-number">3000</span><br></code></pre></td></tr></table></figure><p>等效简化为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WHERE</span> points <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">3000</span><br></code></pre></td></tr></table></figure><h3 id="7-LIKE运算符"><a href="#7-LIKE运算符" class="headerlink" title="7.LIKE运算符"></a>7.LIKE运算符</h3><p>模糊查找，查找具有某种模式的字符串的记录、行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> customers<br><span class="hljs-keyword">WHERE</span> last_name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;brush%&#x27;</span> <span class="hljs-operator">/</span> <span class="hljs-string">&#x27;b___y&#x27;</span><br></code></pre></td></tr></table></figure><p>引号里写上想要的字符串模式，注意SQL几乎不区分大小写</p><p>两种通配符：</p><ul><li><code>%</code> 任何个数（包括0个）的字符（<strong>用的更多</strong>）</li><li><code>_</code> 单个字符</li></ul><p><strong>练习</strong>：</p><p>分别选择满足如下条件的顾客：</p><ol><li><p>地址包含 ‘TRAIL’ 或 ‘AVENUE’</p></li><li><p>电话号码以 9 结束</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> customers<br><span class="hljs-keyword">WHERE</span> address <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%Trail%&#x27;</span> <span class="hljs-keyword">OR</span> <br>  address <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%Avenue%&#x27;</span><br>  <br>  <br><span class="hljs-keyword">WHERE</span> phone <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%9&#x27;</span><br></code></pre></td></tr></table></figure><ol start="8"><li>REGEXP运算符</li></ol><p>正则表达式，在搜索字符串方面更为强大</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> customers<br><span class="hljs-keyword">where</span> last_name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%field%&#x27;</span><br></code></pre></td></tr></table></figure><p>等效于</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">where</span> last_name regexp <span class="hljs-string">&#x27;field&#x27;</span><br></code></pre></td></tr></table></figure><p>正则表达式总结：</p><table><thead><tr><th>符号</th><th>意义</th></tr></thead><tbody><tr><td>^</td><td>开头</td></tr><tr><td>$</td><td>结尾</td></tr><tr><td>[abc]</td><td>含abc的任意字母</td></tr><tr><td>[a-c]</td><td>含a到c的任意字母</td></tr><tr><td>|</td><td>logical or</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">where</span> last_name regexp <span class="hljs-string">&#x27;^mac|field$|rose&#x27;</span> <br><span class="hljs-keyword">where</span> last_name regexp <span class="hljs-string">&#x27;[gi]e|e[fmq]&#x27;</span> <span class="hljs-comment">-- 查找含ge/ie或ef/em/eq的</span><br><span class="hljs-keyword">where</span> last_name regexp <span class="hljs-string">&#x27;[a-h]e|e[c-j]&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>练习</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">分别选择满足如下条件的顾客：<br># <span class="hljs-number">1.</span> <span class="hljs-keyword">first</span> names 是 ELKA 或 AMBUR<br># <span class="hljs-number">2.</span> <span class="hljs-keyword">last</span> names 以 EY 或 <span class="hljs-keyword">ON</span> 结束<br># <span class="hljs-number">3.</span> <span class="hljs-keyword">last</span> names 以 MY 开头 或包含 SE<br># <span class="hljs-number">4.</span> <span class="hljs-keyword">last</span> names 包含 BR 或 BU<br><br><span class="hljs-keyword">where</span> first_name regexp <span class="hljs-string">&#x27;elka|ambur&#x27;</span><br><span class="hljs-keyword">where</span> last_name regexp <span class="hljs-string">&#x27;EY$|ON$&#x27;</span><br><span class="hljs-keyword">where</span> last_name regexp <span class="hljs-string">&#x27;^MY|SE&#x27;</span><br><span class="hljs-keyword">where</span> last_name regexp <span class="hljs-string">&#x27;BR|BU&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="9-IS-NULL运算符"><a href="#9-IS-NULL运算符" class="headerlink" title="9. IS NULL运算符"></a>9. IS NULL运算符</h3><p>找出空值，找出有某种属性缺失的记录</p><p><strong>案例</strong></p><p>找出电话号码缺失的顾客，也许发个邮件提醒他们之类</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> customers<br><span class="hljs-keyword">where</span> phone <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span><span class="hljs-operator">/</span><span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><p>conclusion</p><ul><li>比较运算：&gt; &lt; &#x3D; &gt;&#x3D; &lt;&#x3D; !&#x3D;</li><li>逻辑运算：AND, OR, NOT</li><li>特殊的比较运算：IN, BETWEEN, LIKE, REGEXP, IS NULL</li></ul><p><code>优先级：数学-&gt;比较-&gt;逻辑</code></p><h3 id="10-ORDER-BY子句"><a href="#10-ORDER-BY子句" class="headerlink" title="10. ORDER BY子句"></a>10. ORDER BY子句</h3><p>排序语句</p><ol><li>可多列（先按a排序，a相同的内部再用b排序）</li><li>可以是列间的数字表达式，包括没被select的列也可以作排序条件</li><li>也可以包含任何列&#x2F;之前定义好的别名列</li><li>任何一个排序依据列后面都可选DESC（降序）</li></ol><blockquote><p> 注：workbench 中扳手图标可打开表格的设计模式，查看或修改表中各列（属性），可以看到谁是主键。省略排序语句的话会默认按主键排序</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 订单<span class="hljs-number">2</span>的商品按总价降序排列<br>## 以总价的数学表达式为排序依据<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> order_items<br><span class="hljs-keyword">where</span> order_id <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> quantity <span class="hljs-operator">*</span> unit_price <span class="hljs-keyword">desc</span><br><br>## 先定义总价别名，在以别名为排序依据<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>, quantity <span class="hljs-operator">*</span> unit_price  <span class="hljs-keyword">AS</span> total_price<br><span class="hljs-keyword">FROM</span> order_items<br><span class="hljs-keyword">where</span> order_id <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> total_price <span class="hljs-keyword">desc</span><br></code></pre></td></tr></table></figure><h3 id="11-LIMIT子句"><a href="#11-LIMIT子句" class="headerlink" title="11. LIMIT子句"></a>11. LIMIT子句</h3><p>限制返回结果的记录数量，“前N个” 或 “跳过M个后的前N个”</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> customers<br>limit <span class="hljs-number">3</span> <span class="hljs-operator">/</span> <span class="hljs-number">300</span> <span class="hljs-operator">/</span> <span class="hljs-number">6</span>, <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>6, 3 表示跳过前6个，取第7~9个，6是偏移量，</p><h2 id="【第三章】在多张表格中检索数据"><a href="#【第三章】在多张表格中检索数据" class="headerlink" title="【第三章】在多张表格中检索数据"></a>【第三章】在多张表格中检索数据</h2><p><a href="https://zhuanlan.zhihu.com/p/222968981">https://zhuanlan.zhihu.com/p/222968981</a></p><h3 id="1-内连接"><a href="#1-内连接" class="headerlink" title="1.内连接"></a>1.内连接</h3><p>各表分开存放是为了减少重复信息和方便修改，需要时可以根据相互之间的关系连接成相应的合并详情表以满足相应的查询。FROM JOIN ON 语句就是告诉sql： 将哪几张表以什么基础连接&#x2F;合并起来。</p><p>从后往前看查询语句：</p><ul><li>后面的<code>from</code> 表A <code>join</code> 表B <code>on</code> AB的关系，就是以某些相关联的列为依据，进行多表合并得到所需的详情表</li><li>前面的select就是在合并详情表中找到所需的列</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><br><span class="hljs-keyword">select</span><br>order_id,<br>    o.customer_id,<br>    first_name,<br>    last_name<br><span class="hljs-keyword">from</span> orders <span class="hljs-keyword">as</span> o<br><span class="hljs-keyword">join</span> customers c<br><span class="hljs-keyword">on</span> o.customer_id <span class="hljs-operator">=</span> c.customer_id<br></code></pre></td></tr></table></figure><p>之前在<code>SELECT</code>中给选定的列加别名主要是为了得到更有意义的列名，这里再<code>FROM...JOIN...</code>加别名主要是为了简化。</p><p><code>o.</code>是别名，是在后面的<code>FROM</code>语句里定义的，不用会报错，因为这两个表都有<code>customer_id</code>，这里指定任意一个表的都行，因为是按相同的<code>customer_id</code>来链接两个表。总之选择多种表里都有的同名列时，必须加上表名前缀来明确列的来源。</p><p>同时用了别名后其他地方（包括前面的<code>SELECT</code>语句，因为SQL最先执行<code>FROM...JOIN...</code>）用别名，否则会报错。因此最好先<code>SELECT * FROM</code>选择全部，等写好了<code>FROM...JOIN...ON...</code>等后面的语句，再回头去<code>SELECT</code>里细化明确需要的列。</p><h3 id="2-跨数据库连接（合并）"><a href="#2-跨数据库连接（合并）" class="headerlink" title="2.跨数据库连接（合并）"></a>2.跨数据库连接（合并）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">use sql_store;<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> order_items oi<br><span class="hljs-keyword">join</span> sql_inventory.products p<br><span class="hljs-keyword">on</span> oi.product_id <span class="hljs-operator">=</span> p.product_id<br></code></pre></td></tr></table></figure><p>有时需要选取不同库的表的列，其他都一样，只需要对<code>join</code>里非正在使用<code>use</code>的库的表要加上库名前缀而已。</p><h3 id="3-多表连接"><a href="#3-多表连接" class="headerlink" title="3.多表连接"></a>3.多表连接</h3><p><code>FROM</code>一个核心表A，用多个<code>JOIN...ON...</code>分别通过不同的链接关系链接不同的表B,C,D,…, 通过是让表B、C、D…为表A提供更详细的信息从而合并为一张详情合并版A表，即</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">FROM</span> A<br><span class="hljs-keyword">JOIN</span> B <span class="hljs-keyword">ON</span> AB的关系<br><span class="hljs-keyword">JOIN</span> C <span class="hljs-keyword">ON</span> AC的关系<br><span class="hljs-keyword">JOIN</span> D <span class="hljs-keyword">ON</span> AD的关系<br>...<br></code></pre></td></tr></table></figure><p>将得到一个合并BCD…等表详细信息的详情合并版A表</p><p>Case1：订单表同时链接顾客表和订单状态表，合并为有顾客和状态信息的详细订单表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br> <span class="hljs-keyword">SELECT</span> <br> o.order_id,<br> o.order_date,<br> c.first_name,<br> c.last_name <br> os.name <span class="hljs-keyword">AS</span> status<br> <span class="hljs-keyword">FROM</span> orders o<br> <span class="hljs-keyword">JOIN</span> customers c <br> <span class="hljs-keyword">ON</span> o.customer_id <span class="hljs-operator">=</span> c.customer_id<br> <span class="hljs-keyword">JOIN</span> order_statuses os<br> <span class="hljs-keyword">ON</span> o.status <span class="hljs-operator">=</span> os.order_status_id <br></code></pre></td></tr></table></figure><img src="/2023/11/05/sql-mosh/image-20231105210011981.png" alt="image-20231105210011981" style="zoom:50%;"><h3 id="5-符合连接条件"><a href="#5-符合连接条件" class="headerlink" title="5.符合连接条件"></a>5.符合连接条件</h3><p>像订单（orders）这种表，order_id可以唯一表示一条记录</p><img src="/2023/11/05/sql-mosh/image-20231105210024049.png" alt="image-20231105210024049" style="zoom:50%;"><p>像订单项目（order_items）这种表，<strong>订单id和产品id合在一起才能唯一表示一条记录</strong>，这叫<strong>复合主键</strong>；设计模式下也可以看到这两个字段都有PK标识，订单项目备注表（order_item_notes）也是这两个复合主键，因此他们两合并时要用复合条件：</p><p><code>FROM</code> 表1 <code>JOIN</code> 表2 <code>ON</code> 条件1 <code>【AND】</code> 条件2</p><h3 id="6-隐式连接语法"><a href="#6-隐式连接语法" class="headerlink" title="6. 隐式连接语法"></a>6. 隐式连接语法</h3><p>用<code>from where</code>取代<code>from join on</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span> orders o<br><span class="hljs-keyword">JOIN</span> customers c<br>    <span class="hljs-keyword">ON</span> o.customer_id <span class="hljs-operator">=</span> c.customer_id<br>    <br>    <br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> orders o, customers c<br><span class="hljs-keyword">WHERE</span> o.customer_id <span class="hljs-operator">=</span> c.customer_id<br></code></pre></td></tr></table></figure><p>尽量别用，因为若忘记WHERE条件筛选语句，不会报错但会得到交叉合并（cross join）结果：即10条order会分别与10个customer结合，得到100条记录。最好使用显性合并语法，因为会强制要求你写合并条件ON语句，不至于漏掉。</p><h3 id="7-外连接"><a href="#7-外连接" class="headerlink" title="7.外连接"></a>7.外连接</h3><ol><li><code>(INNER) JOIN</code> 结果只包含两表的交集</li><li><code>LEFT/RIGHT(OUTER)JOIN</code>结果里除了交集，还包含只出现在左&#x2F;右表中的记录。</li></ol><p>展示各产品在订单项目中出现的记录和销量，也要包括没有订单的产品</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>    p.product_id,<br>    p.name, <span class="hljs-comment">-- 或者直接name</span><br>    oi.quantity <span class="hljs-comment">-- 或者直接quantity</span><br><span class="hljs-keyword">FROM</span> products p<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> order_items oi<br>    <span class="hljs-keyword">ON</span> p.product_id <span class="hljs-operator">=</span> oi.product_id<br></code></pre></td></tr></table></figure><p>当使用左连接时，所有左表的记录会被返回，不管条件正确还是错误。</p><h3 id="8-多表外连接"><a href="#8-多表外连接" class="headerlink" title="8.多表外连接"></a>8.多表外连接</h3><p>查询顾客、订单和发货商记录，要包括所有顾客（包括无订单的顾客），也要包括所有订单（包括未发出的）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><br><span class="hljs-keyword">SELECT</span> <br>    c.customer_id,<br>    c.first_name,<br>    o.order_id,<br>    sh.name <span class="hljs-keyword">AS</span> shipper<br><span class="hljs-keyword">FROM</span> customers c<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> orders o <span class="hljs-comment">-- 包括无订单的顾客</span><br>    <span class="hljs-keyword">ON</span> c.customer_id <span class="hljs-operator">=</span> o.customer_id<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> shippers sh  <span class="hljs-comment">-- 包括未发出的</span><br>    <span class="hljs-keyword">ON</span> o.shipper_id <span class="hljs-operator">=</span> sh.shipper_id<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> customer_id<br></code></pre></td></tr></table></figure><p><strong>练习</strong></p><p>查询 订单 + 顾客 + 发货商 + 订单状态，包括所有的订单（包括未发货的），其实就只是前两个优先级变了一下，是要看全部订单而非全部顾客了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><br><span class="hljs-keyword">SELECT</span> <br>o.order_id,<br>o.order_date,<br>c.first_name <span class="hljs-keyword">AS</span> customer,<br>sh.name <span class="hljs-keyword">AS</span> shipper,<br>os.name <span class="hljs-keyword">AS</span> status<br><span class="hljs-keyword">FROM</span> orders o<br><span class="hljs-keyword">JOIN</span> customers c<br><span class="hljs-keyword">ON</span> o.customer_id <span class="hljs-operator">=</span> c.customer_id<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> shippers sh<br><span class="hljs-keyword">ON</span> o.shipper_id <span class="hljs-operator">=</span> sh.shipper_id<br><span class="hljs-keyword">JOIN</span> order_statuses os<br><span class="hljs-keyword">ON</span> o.status <span class="hljs-operator">=</span> os.order_status_id<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> o.order_id<br></code></pre></td></tr></table></figure><h3 id="9-自我外部连接"><a href="#9-自我外部连接" class="headerlink" title="9.自我外部连接"></a>9.自我外部连接</h3><p>就用前面那个员工表的例子来说，就是用<code>LEFT JOIN</code>让得到的 员工-上级 合并表也包括老板本人（老板没有上级，即<code> reports_to</code> 字段为空，如果用<code> JOIN</code> 会被筛掉，用<code> LEFT JOIN</code> 才能保留）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_hr;<br><br><span class="hljs-keyword">SELECT</span> <br>e.employee_id,<br>    e.first_name,<br>    m.first_name <span class="hljs-keyword">AS</span> manager<br><span class="hljs-keyword">FROM</span> employees e<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> employees m<br><span class="hljs-keyword">ON</span> e.reports_to <span class="hljs-operator">=</span> m.employee_id<br></code></pre></td></tr></table></figure><h3 id="10-USING字句"><a href="#10-USING字句" class="headerlink" title="10.USING字句"></a>10.USING字句</h3><p>当作为合并条件（join condition）的列在两个表中有相同的列名时，可用 <code>USING (……, ……)</code> 取代 <code>ON …… AND ……</code> 予以简化，内&#x2F;外链接均可如此简化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span><br>    o.order_id,<br>    c.first_name,<br>    sh.name <span class="hljs-keyword">AS</span> shipper<br><span class="hljs-keyword">FROM</span> orders o<br><span class="hljs-keyword">JOIN</span> customers c<br>    <span class="hljs-keyword">USING</span> (customer_id) <span class="hljs-comment">-- ON o.customer_id = c.customer_id</span><br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> shippers sh<br>    <span class="hljs-keyword">USING</span> (shipper_id) <span class="hljs-comment">-- ON o.shipper_id = c.shipper_id</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> order_id<br></code></pre></td></tr></table></figure><p><strong>复合主键</strong>表间复合连接条件的合并也可用 USING，中间逗号隔开就行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> order_items oi<br><span class="hljs-keyword">JOIN</span> order_item_notes oin<br><br><span class="hljs-keyword">ON</span> oi.order_id <span class="hljs-operator">=</span> oin.order_Id <span class="hljs-keyword">AND</span><br>    oi.product_id <span class="hljs-operator">=</span> oin.product_id<br><span class="hljs-operator">/</span><span class="hljs-keyword">USING</span> (order_id, product_id)<br></code></pre></td></tr></table></figure><p><strong>练习</strong></p><p>sql_invoicing库里，将payments、clients、payment_methods三张表合并起来，以知道什么日期哪个顾客用什么方式付了多少钱</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_invoicing;<br><span class="hljs-keyword">SELECT</span> <br>p.date,<br>    c.name <span class="hljs-keyword">AS</span> client,<br>    p.amount,<br>pm.name <span class="hljs-keyword">AS</span> payment_method<br><span class="hljs-keyword">FROM</span> clients c<br><span class="hljs-keyword">JOIN</span> payments p<br><span class="hljs-keyword">USING</span>(client_id)<br><span class="hljs-keyword">JOIN</span> payment_methods pm<br><span class="hljs-keyword">ON</span> pm.payment_method_id <span class="hljs-operator">=</span> p.payment_method<br></code></pre></td></tr></table></figure><h3 id="11-自然连接"><a href="#11-自然连接" class="headerlink" title="11.自然连接"></a>11.自然连接</h3><p><code>NATURAL JOIN</code> 就是让MySQL自动检索同名列作为合并条件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><br><span class="hljs-keyword">SELECT</span> <br>    o.order_id,<br>    c.first_name<br><span class="hljs-keyword">FROM</span> orders o<br><span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">JOIN</span> customers c<br></code></pre></td></tr></table></figure><blockquote><p>最好别用，因为不确定合并条件是否找对了，有时会造成无法预料的问题，编程时保持对结果的<strong>控制</strong>是非常重要的</p><p>但也要知道有这个东西，混个脸熟，不要别人用了看不懂。</p></blockquote><h3 id="12-交叉连接"><a href="#12-交叉连接" class="headerlink" title="12.交叉连接"></a>12.交叉连接</h3><p>得到名字和产品的所有组合，因此不需要合并条件。 实际运用如：要得到尺寸和颜色的全部组合</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><br><span class="hljs-keyword">SELECT</span> <br>    c.first_name <span class="hljs-keyword">AS</span> customer,<br>    p.name <span class="hljs-keyword">AS</span> product<br><span class="hljs-keyword">FROM</span> customers c<br><span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> products p<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> c.first_name<br></code></pre></td></tr></table></figure><p>上面是显性语法，还有隐式语法，之前讲过，其实就是隐式内容并忽略WHERE子句（即合并条件）的情况，也就是把 <code>CROSS JOIN</code> 改为逗号，即 <code>FROM A CROSS JOIN B</code> 等效于 <code>FROM A, B</code>，Mosh更推荐显式语法，因为更清晰</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><br><span class="hljs-keyword">SELECT</span> <br>    c.first_name,<br>    p.name<br><span class="hljs-keyword">FROM</span> customers c, products p<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> c.first_name<br></code></pre></td></tr></table></figure><h3 id="13-联合"><a href="#13-联合" class="headerlink" title="13.联合"></a>13.联合</h3><p><code>FROM …… JOIN ……</code> 可对多张表进行横向列合并，而 <code>…… UNION ……</code> 可用来按行纵向合并多个查询结果，这些查询结果可能来自相同或不同的表</p><ul><li>同一张表可通过<code>UNION</code>添加新的分类字段，即先通过分类查询并添加新的分类字段再<code>UNION</code>合并为带分类字段的新表。</li><li>不同表通过<code>UNION</code>合并的情况如：将一张18年的订单表和19年的订单表纵向合并起来在一张表里展示</li></ul><p>注意</p><ul><li>合并的查询结果必须列数相等，否则会报错</li><li>合并表里的列名由排在 UNION 前面的决定</li></ul><p>给订单表增加一个新字段——status，用以区分今年的订单和今年以前的订单</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><br>    <span class="hljs-keyword">SELECT</span> <br>        order_id,<br>        order_date,<br>        <span class="hljs-string">&#x27;Active&#x27;</span> <span class="hljs-keyword">AS</span> status<br>    <span class="hljs-keyword">FROM</span> orders<br>    <span class="hljs-keyword">WHERE</span> order_date <span class="hljs-operator">&gt;=</span> <span class="hljs-string">&#x27;2019-01-01&#x27;</span><br><br><span class="hljs-keyword">UNION</span><br><br>    <span class="hljs-keyword">SELECT</span> <br>        order_id,<br>        order_date,<br>        <span class="hljs-string">&#x27;Archived&#x27;</span> <span class="hljs-keyword">AS</span> status  <span class="hljs-comment">-- Archived 归档</span><br>    <span class="hljs-keyword">FROM</span> orders<br>    <span class="hljs-keyword">WHERE</span> order_date <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;2019-01-01&#x27;</span>;<br>    <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> order_id<br></code></pre></td></tr></table></figure><p>可以看出ORDER BY的优先级在UNION之后，</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>感觉本质上可以将查询语句的任何一步和任何一个层次，包括：</p><ol><li>横纵筛选 <code>SELECT ……``WHERE ……</code></li><li>选表 <code>FROM ……</code></li><li>横纵连接 <code>…… JOIN ……``…… UNION ……</code></li><li>排序、限制<code>ORDER BY ……``LIMIT ……</code></li></ol><p>都看作暂时生成了一张新表（虚拟表），将后续步骤都看作是在对这些新表进行进一步的操作， 这样，层次步骤就能理清，就好理解了，也才真的能从本质上掌握并灵活运用</p><h2 id="【第四章】插入、更新和删除数据"><a href="#【第四章】插入、更新和删除数据" class="headerlink" title="【第四章】插入、更新和删除数据"></a>【第四章】插入、更新和删除数据</h2><h3 id="1-列属性"><a href="#1-列属性" class="headerlink" title="1. 列属性"></a>1. 列属性</h3><p>点击表的扳手按钮：打开设计模式，介绍了一些表中字段&#x2F;列的属性。</p><p><img src="/2023/11/05/sql-mosh/image-20231026170906220.png" alt="image-20231026170906220"></p><ul><li>Datatype：数据类型 int 整数型 varchar 可变字符</li><li>PK：主键</li><li>NN：非空值（决定该列是否可以写空值 √否）</li><li>AI：自动递增（通常被用在主键列，每次我们在表中插入一条新纪录，我们让MySQL在列中插入一个值，同时主键列加一）</li><li>Default：默认值</li></ul><h3 id="2-插入单行"><a href="#2-插入单行" class="headerlink" title="2. 插入单行"></a>2. 插入单行</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 目标表（目标列，可选，逗号隔开）<br><span class="hljs-keyword">VALUES</span>（目标值，逗号隔开）<br></code></pre></td></tr></table></figure><p>法1. 若不指明列名，则插入的值必须按所有字段的顺序完整插入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> customers <span class="hljs-comment">-- 目标表</span><br><span class="hljs-keyword">VALUES</span> (<br>    <span class="hljs-keyword">DEFAULT</span>,<br>    <span class="hljs-string">&#x27;Michael&#x27;</span>,<br>    <span class="hljs-string">&#x27;Jackson&#x27;</span>,<br>    <span class="hljs-string">&#x27;1958-08-29&#x27;</span>,  <span class="hljs-comment">-- DEFAULT/NULL/&#x27;1958-08-29&#x27;</span><br>    <span class="hljs-keyword">DEFAULT</span>,<br>    <span class="hljs-string">&#x27;5225 Figueroa Mountain Rd&#x27;</span>, <br>    <span class="hljs-string">&#x27;Los Olivos&#x27;</span>,<br>    <span class="hljs-string">&#x27;CA&#x27;</span>,<br>    <span class="hljs-keyword">DEFAULT</span><br>    );<br></code></pre></td></tr></table></figure><p>法2. 指明列名，可跳过取默认值的列且可更改顺序，一般用这种，更清晰</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> customers (<br>    address,<br>    city,<br>    state,<br>    last_name,<br>    first_name,<br>    birth_date,<br>    )<br><span class="hljs-keyword">VALUES</span> (<br>    <span class="hljs-string">&#x27;5225 Figueroa Mountain Rd&#x27;</span>,<br>    <span class="hljs-string">&#x27;Los Olivos&#x27;</span>,<br>    <span class="hljs-string">&#x27;CA&#x27;</span>,<br>    <span class="hljs-string">&#x27;Jackson&#x27;</span>,<br>    <span class="hljs-string">&#x27;Michael&#x27;</span>,    <br>    <span class="hljs-string">&#x27;1958-08-29&#x27;</span>,  <br>    )<br>```<br></code></pre></td></tr></table></figure><h3 id="3-插入多行"><a href="#3-插入多行" class="headerlink" title="3. 插入多行"></a>3. 插入多行</h3><p><code>VALUES ……</code> 里一行内数据用<strong>括号内逗号</strong>隔开，而多行数据用<strong>括号间逗号</strong>隔开</p><ul><li>插入多条运货商信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> shippers (name)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;shipper1&#x27;</span>),<br>       (<span class="hljs-string">&#x27;shipper2&#x27;</span>),<br>       (<span class="hljs-string">&#x27;shipper3&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li>插入多条产品信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br>#way1<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> products <br><span class="hljs-keyword">VALUES</span> (<span class="hljs-keyword">DEFAULT</span>, <span class="hljs-string">&#x27;product1&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>),<br>       (<span class="hljs-keyword">DEFAULT</span>, <span class="hljs-string">&#x27;product2&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">20</span>),<br>       (<span class="hljs-keyword">DEFAULT</span>, <span class="hljs-string">&#x27;product3&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">30</span>)<br># way2<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> products(name, quantity_in_stock, unit_price)<br><span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;product1&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">10</span>),<br>  (<span class="hljs-string">&#x27;product2&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">20</span>),<br>      (<span class="hljs-string">&#x27;product3&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;30&#x27;</span>)<br>      <br></code></pre></td></tr></table></figure><h3 id="4-插入分级行"><a href="#4-插入分级行" class="headerlink" title="4. 插入分级行"></a>4. 插入分级行</h3><p>订单表（orders表）里的一条记录对应订单项目表（order_items表）里的多条记录，一对多，是相互关联的父子表。通过添加&#x3D;&#x3D;一条&#x3D;&#x3D;订单记录和对应的&#x3D;&#x3D;多条&#x3D;&#x3D;订单项目记录，学习如何向父子表插入分级（层）&#x2F;耦合数据（insert hierarchical data）：</p><ul><li><p>关键：在插入子表记录时，需要用内建函数 <code>LAST_INSERT_ID()</code> 获取相关父表记录的自增ID（这个例子中就是 order_id)</p><blockquote><p>内建函数：MySQL里有很多可用的内置函数，也就是可复用的代码块，各有不同的功能，注意函数名的单词之间用下划线连接</p><p><code>LAST_INSERT_ID()</code>：获取最新的成功的 <code>INSERT 语句</code> 中的自增id，在这个例子中就是父表里新增的 order_id.</p></blockquote></li></ul><p><strong>案例</strong></p><p>新增一个订单（order），里面包含两个订单项目&#x2F;两种商品（order_items），请同时更新订单表和订单项目表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> orders (customer_id, order_date, status)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2019-01-01&#x27;</span>, <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">-- 可以先试一下用 SELECT last_insert_id() 看能否成功获取到的最新的 order_id</span><br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> order_items  <span class="hljs-comment">-- 全是必须字段，就不用指定了</span><br><span class="hljs-keyword">VALUES</span> <br>    (last_insert_id(), <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2.5</span>),<br>    (last_insert_id(), <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1.5</span>)<br></code></pre></td></tr></table></figure><h3 id="5-创建表的副本"><a href="#5-创建表的副本" class="headerlink" title="5. 创建表的副本"></a>5. 创建表的副本</h3><p>CREAT TABLE 新表名 AS 子查询</p><p><code>主键不会复制</code></p><p><strong>案例1</strong></p><p>运用 <code>CREAT TABLE 新表名 AS 子查询</code> 快速创建表 orders 的副本表 orders_archived</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> orders_archived <span class="hljs-keyword">AS</span><br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders  <span class="hljs-comment">-- 子查询</span><br></code></pre></td></tr></table></figure><p><code>SELECT * FROM orders</code> 选择了 oders 中所有数据，作为AS的内容，是一个子查询</p><ul><li>子查询： 任何一个充当另一个SQL语句的一部分的 <code>SELECT……</code> 查询语句都是子查询，子查询是一个很有用的技巧</li></ul><p><strong>案例2</strong></p><p>不再用全部数据，而选用原表中部分数据创建副本表，如今年以前的orders创建一个副本orders_archived，其实就是在子查询中增加了一个where语句进行筛选。&#96;注意要先drop删掉或truncate清空掉之前的orders_archive表再重建或重新插入数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> orders_archived;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> orders_archived <span class="hljs-keyword">AS</span><br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders  <span class="hljs-comment">-- 子查询</span><br>    <span class="hljs-keyword">WHERE</span> order_date <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;2019-01-01&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>练习</strong></p><p>创建一个存档发票表，只包含有过支付记录的发票并将顾客id换成顾客名字</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SQL">USE sql_invoicing;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> invoices_archived <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> i.invoice_id, c.name <span class="hljs-keyword">AS</span> client, i.payment_date<br><span class="hljs-keyword">FROM</span> invoices i<br><span class="hljs-keyword">JOIN</span> clients c<br><span class="hljs-keyword">USING</span> (client_id)<br><span class="hljs-keyword">WHERE</span> i.payment_date <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br></code></pre></td></tr></table></figure><h3 id="6-更新单行"><a href="#6-更新单行" class="headerlink" title="6. 更新单行"></a>6. 更新单行</h3><p>用 <code>UPDATE ……</code> 语句 来修改表中的一条或多条记录，具体语法结构：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> 表 <br><span class="hljs-keyword">SET</span> 要修改的字段 <span class="hljs-operator">=</span> 具体值<span class="hljs-operator">/</span><span class="hljs-keyword">NULL</span><span class="hljs-operator">/</span><span class="hljs-keyword">DEFAULT</span><span class="hljs-operator">/</span>列间数学表达式 （修改多个字段用逗号分隔）<br><span class="hljs-keyword">WHERE</span> 行筛选<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_invoicing;<br><br><span class="hljs-keyword">UPDATE</span> invoices<br><span class="hljs-keyword">SET</span> <br>    payment_total <span class="hljs-operator">=</span> <span class="hljs-number">100</span> <span class="hljs-operator">/</span> <span class="hljs-number">0</span> <span class="hljs-operator">/</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-operator">/</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">/</span> <span class="hljs-number">0.5</span> <span class="hljs-operator">*</span> invoice_total, <br>    <span class="hljs-comment">/*注意 0.5 * invoice_total 的结果小数部分会被舍弃，</span><br><span class="hljs-comment">    之后讲数据类型会讲到这个问题*/</span><br>    payment_date <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2019-01-01&#x27;</span> <span class="hljs-operator">/</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-operator">/</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">/</span> due_date<br><span class="hljs-keyword">WHERE</span> invoice_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="7-更新多行"><a href="#7-更新多行" class="headerlink" title="7. 更新多行"></a>7. 更新多行</h3><p>语法一样的，就是让 <code>WHERE……</code> 的条件包含更多记录，就会同时更改多条记录了</p><p><strong>注意</strong></p><p>Workbench默认开启了Safe Updates功能，不允许同时更改多条记录，要先关闭该功能（在 Edit-Preferences-SQL Editor-Safe Updates）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_invoicing;<br><br><span class="hljs-keyword">UPDATE</span> invoices<br><span class="hljs-keyword">SET</span> payment_total <span class="hljs-operator">=</span> <span class="hljs-number">233</span>, payment_date <span class="hljs-operator">=</span> due_date<br><span class="hljs-keyword">WHERE</span> client_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>  <br><span class="hljs-comment">-- 该客户的发票记录不止一条，将同时更改</span><br><span class="hljs-operator">/</span><span class="hljs-keyword">WHERE</span> client_id <span class="hljs-keyword">IN</span> (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <br><span class="hljs-comment">-- 第二章 4~9 讲的那些写 WHERE 条件的方法均可用</span><br><span class="hljs-comment">-- 甚至可以直接省略 WHERE 语句，会直接更改整个表的全部记录</span><br></code></pre></td></tr></table></figure><h3 id="8-在updates中用子查询"><a href="#8-在updates中用子查询" class="headerlink" title="8. 在updates中用子查询"></a>8. 在updates中用子查询</h3><p>本质上是将子查询用在<code>where</code>行筛选条件中</p><p><strong>案例</strong></p><p>更改发票记录表中名字叫 Yadel 的记录，但该表只有 client_id，故先要从另一个顾客表中查询叫 Yadel 人的 client_id</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_invoicing;<br><br><span class="hljs-keyword">UPDATE</span> invoices<br><span class="hljs-keyword">SET</span> payment_total <span class="hljs-operator">=</span> <span class="hljs-number">233</span>, payment_date <span class="hljs-operator">=</span> due_date<br><span class="hljs-keyword">WHERE</span> client_id <span class="hljs-operator">=</span> (<br><span class="hljs-keyword">SELECT</span> client_id<br><span class="hljs-keyword">FROM</span> clients <br><span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Myworks&#x27;</span>)<br>  <span class="hljs-comment">-- 放入括号，确保先执行</span><br><br><span class="hljs-comment">-- 若子查询返回多个数据（一列多条数据）时就不能用等号而要用 IN 了：</span><br><span class="hljs-keyword">WHERE</span> client_id <span class="hljs-keyword">IN</span> <br>    (<span class="hljs-keyword">SELECT</span> client_id <br>    <span class="hljs-keyword">FROM</span> clients<br>    <span class="hljs-keyword">WHERE</span> state <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;CA&#x27;</span>, <span class="hljs-string">&#x27;NY&#x27;</span>))<br></code></pre></td></tr></table></figure><p>确保WHERE行筛选条件准确准确无误后，再放到修改语句后执行修改：</p><h3 id="9-删除行"><a href="#9-删除行" class="headerlink" title="9. 删除行"></a>9. 删除行</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表 <br><span class="hljs-keyword">WHERE</span> 行筛选条件<br>（当然也可用子查询）<br>（若省略 <span class="hljs-keyword">WHERE</span> 条件语句会删除表中所有记录（和 <span class="hljs-keyword">TRUNCATE</span> 等效？））<br></code></pre></td></tr></table></figure><h3 id="10-恢复数据库"><a href="#10-恢复数据库" class="headerlink" title="10. 恢复数据库"></a>10. 恢复数据库</h3><p>Restoring the Databases (1:06)</p><p>就是重新运行那个 create-databases.sql 文件以重置数据库</p><h1 id="第二部分：基础进阶–汇总、复杂查询、内置函数"><a href="#第二部分：基础进阶–汇总、复杂查询、内置函数" class="headerlink" title="第二部分：基础进阶–汇总、复杂查询、内置函数"></a>第二部分：基础进阶–汇总、复杂查询、内置函数</h1><h2 id="【第五章】汇总数据"><a href="#【第五章】汇总数据" class="headerlink" title="【第五章】汇总数据"></a>【第五章】汇总数据</h2><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>聚合函数：<strong>输入一系列值并聚合为一个结果</strong>的函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_invoicing;<br><br><span class="hljs-keyword">SELECT</span> <br>    <span class="hljs-built_in">MAX</span>(invoice_date) <span class="hljs-keyword">AS</span> latest_date,  <br>    <span class="hljs-comment">-- SELECT选择的不仅可以是列，也可以是数字、列间表达式、列的聚合函数</span><br>    <span class="hljs-built_in">MIN</span>(invoice_total) lowest,<br>    <span class="hljs-built_in">AVG</span>(invoice_total) average,<br>    <span class="hljs-built_in">SUM</span>(invoice_total <span class="hljs-operator">*</span> <span class="hljs-number">1.1</span>) total,<br>    <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) total_records,<br>    <span class="hljs-built_in">COUNT</span>(invoice_total) number_of_invoices, <br>    <span class="hljs-comment">-- 和上一个相等</span><br>    <span class="hljs-built_in">COUNT</span>(payment_date) number_of_payments,  <br>    <span class="hljs-comment">-- 【聚合函数会忽略空值】，得到的支付数少于发票数</span><br>    <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> client_id) number_of_distinct_clients<br>    <span class="hljs-comment">-- DISTINCT client_id 筛掉了该列的重复值，再COUNT计数，会得到不同顾客数</span><br><span class="hljs-keyword">FROM</span> invoices<br><span class="hljs-keyword">WHERE</span> invoice_date <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;2019-07-01&#x27;</span>  <span class="hljs-comment">-- 想只统计下半年的结果</span><br></code></pre></td></tr></table></figure><h3 id="GROUP-BY-子句"><a href="#GROUP-BY-子句" class="headerlink" title="GROUP BY 子句"></a>GROUP BY 子句</h3><p>按一列或多列分组，注意语句的位置。</p><ul><li>案例1：按一个字段分组</li></ul><p>在发票记录表中<strong>按不同顾客分组统计</strong>下半年总销售额并降序排列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_invoicing;<br><br><span class="hljs-keyword">SELECT</span> <br>    client_id,  #只有聚合函数是按 client_id 分组时，这里选择 client_id 列才有意义（分组统计语句里<span class="hljs-keyword">SELECT</span>通常都是选择分组依据列<span class="hljs-operator">+</span>目标统计列的聚合函数，选别的列没意义）<br>    <span class="hljs-built_in">SUM</span>(invoice_total) <span class="hljs-keyword">AS</span> total_sales<br><span class="hljs-keyword">FROM</span> invoices<br><span class="hljs-keyword">WHERE</span> invoice_date <span class="hljs-operator">&gt;=</span> <span class="hljs-string">&#x27;2019-07-01&#x27;</span>  <span class="hljs-comment">-- 筛选，过滤器</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> client_id  <span class="hljs-comment">-- 分组</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> invoice_total <span class="hljs-keyword">DESC</span><br><br></code></pre></td></tr></table></figure><p><code>select—from—where—group by—order by</code></p><ul><li>案例2：按多个字段分组</li></ul><p>算<strong>各州各城市</strong>的总销售额</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_invoicing;<br><br><span class="hljs-keyword">SELECT</span> <br>state,<br>city, <br><span class="hljs-built_in">SUM</span>(invoce_total) <span class="hljs-keyword">AS</span> total_sales<br><span class="hljs-keyword">FROM</span> invoices<br><span class="hljs-keyword">JOIN</span> clients <span class="hljs-keyword">USING</span>(client_id)<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> state,city<br></code></pre></td></tr></table></figure><h3 id="HAVING-子句"><a href="#HAVING-子句" class="headerlink" title="HAVING 子句"></a>HAVING 子句</h3><p>HAVING 和 WHERE 都是条件筛选语句，条件的写法相通，数学、比较（包括特殊比较）、逻辑运算都可以用（如 AND、REGEXP 等等）</p><p>区别</p><ul><li>where是对from…join…里原表中的列进行事前筛选，所以WHERE可以对没选择的列进行筛选，所以必须用原表列名而不能用select确定的列别名。</li><li>而having…对select…查询后（通常是分组并聚合查询后）的结果列进行筛选，若SELECT里起了别名的字段则必须用别名进行筛选，且不能对SELECT里未选择的字段进行筛选。</li></ul><p><strong>案例</strong></p><p>筛选出总发票金额大于500且总发票数量大于5的顾客</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_invoicing;<br><br><span class="hljs-keyword">SELECT</span> <br>    client_id,<br>    <span class="hljs-built_in">SUM</span>(invoice_total) <span class="hljs-keyword">AS</span> total_sales,<br>    <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span><span class="hljs-operator">/</span>invoice_total<span class="hljs-operator">/</span>invoice_date) <span class="hljs-keyword">AS</span> number_of_invoices<br><span class="hljs-keyword">FROM</span> invoices<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> client_id<br><span class="hljs-keyword">HAVING</span> total_sales <span class="hljs-operator">&gt;</span> <span class="hljs-number">500</span> <span class="hljs-keyword">AND</span> number_of_invoices <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span><br><span class="hljs-comment">-- 均为 SELECT 里的列别名</span><br></code></pre></td></tr></table></figure><p>练习</p><p>在 sql_store 数据库（有顾客表、订单表、订单项目表等）中，找出在 ‘VA’ 州且消费总额超过100美元的顾客（这是一个面试级的问题，还很常见）</p><p>思路：</p><ol><li>需要的信息在顾客表、订单表、订单项目表三张表中，先将三张表合并</li><li>WHERE 事前筛选 ‘VA’ 州的</li><li>按顾客分组，并选取所需的列并聚合得到每位顾客的付款总额</li><li>HAVING 事后筛选超过 100美元 的</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_invoicing;<br><br><span class="hljs-keyword">SELECT</span> <br>    client_id,<br>    <span class="hljs-built_in">SUM</span>(invoice_total) <span class="hljs-keyword">AS</span> total_sales,<br>    <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span><span class="hljs-operator">/</span>invoice_total<span class="hljs-operator">/</span>invoice_date) <span class="hljs-keyword">AS</span> number_of_invoices<br><span class="hljs-keyword">FROM</span> invoices<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> client_id<br><span class="hljs-keyword">HAVING</span> total_sales <span class="hljs-operator">&gt;</span> <span class="hljs-number">500</span> <span class="hljs-keyword">AND</span> number_of_invoices <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span><br><span class="hljs-comment">-- 均为 SELECT 里的列别名</span><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><br><span class="hljs-keyword">SELECT</span><br>customer_id,<br>c.first_name,<br>c.last_name,<br><span class="hljs-built_in">SUM</span>(oi.quantity <span class="hljs-operator">*</span> oi.unit_price) <span class="hljs-keyword">AS</span> total_sales<br><span class="hljs-keyword">FROM</span> customers c<br><span class="hljs-keyword">JOIN</span> orders o <span class="hljs-keyword">USING</span>(customer_id)<br><span class="hljs-keyword">JOIN</span> order_items oi <span class="hljs-keyword">USING</span>(order_id)<br><span class="hljs-keyword">WHERE</span> state <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;VA&#x27;</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <br>customer_id,<br>c.first_name,<br>c.last_name<br><span class="hljs-keyword">HAVING</span> total_sales <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h3 id="ROLLUP运算符"><a href="#ROLLUP运算符" class="headerlink" title="ROLLUP运算符"></a>ROLLUP运算符</h3><p><code>group by... with roll up</code> 自动汇总型分组，若是多字段分组汇总也是<u>多层次</u>的。</p><p>例1：分组查询各州、市的总销售额（发票总额）以及州层次和全国层次的两个层次的汇总额</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>    state,<br>    city,<br>    <span class="hljs-built_in">SUM</span>(invoice_total) <span class="hljs-keyword">AS</span> total_sales<br><span class="hljs-keyword">FROM</span> invoices<br><span class="hljs-keyword">JOIN</span> clients <span class="hljs-keyword">USING</span> (client_id) <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> state, city <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">ROLLUP</span><br></code></pre></td></tr></table></figure><p>例2：分组计算各个付款方式的总付款并汇总</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_invoicing;<br><br><span class="hljs-keyword">SELECT</span> <br>pm.name <span class="hljs-keyword">AS</span> payment_method,<br>    <span class="hljs-built_in">SUM</span>(amount) <span class="hljs-keyword">AS</span> total<br><span class="hljs-keyword">FROM</span> payments p<br><span class="hljs-keyword">JOIN</span> payment_methods pm<br><span class="hljs-keyword">ON</span> pm.payment_method_id <span class="hljs-operator">=</span> p.payment_id<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> pm.name <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">ROLLUP</span><br></code></pre></td></tr></table></figure><p><strong>★总结</strong></p><p>根据之后三篇参考文章，据说标准的 SQL 查询语句的执行顺序应该是下面这样的：</p><ol><li>FROM JOIN 选择和连接本次查询所需的表</li><li>ON&#x2F;USING WHERE 按条件筛选行</li><li>GROUP BY 分组</li><li>SELECT 筛选列<br>  注意1：若进行了分组，这一步常常要聚合<br>  注意2：SELECT 和 HAVING 在 MySQL 里的执行顺序我还有点疑问，见后面的叙述</li><li>HAVING （事后&#x2F;分组后）筛选行</li><li>DISTINCT 去重</li><li>UNION 纵向合并</li><li>ORDER BY 排序</li><li>LIMIT 限制</li></ol><p>“SELECT 是在大部分语句执行了之后才执行的，严格的说是在 FROM、WHERE 和 GROUP BY 之后执行的。理解这一点是非常重要的，<strong>这就是你不能在 WHERE 中使用在 SELECT 中设定别名的字段作为判断条件的原因。</strong>“</p><p>而 HAVING 必须用 SELECT 选中列（聚合函数除外）</p><h2 id="【第六章】编写复杂查询"><a href="#【第六章】编写复杂查询" class="headerlink" title="【第六章】编写复杂查询"></a>【第六章】编写复杂查询</h2><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>子查询： 任何一个充当另一个SQL语句的一部分的 SELECT…… 查询语句都是子查询，子查询是一个很有用的技巧。子查询的层级用括号实现。</p><p>例1：在 products 中，找到所有比生菜（id &#x3D; 3）价格高的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> unit_price <span class="hljs-operator">&gt;</span> (<br><span class="hljs-keyword">SELECT</span> unit_price<br>    <span class="hljs-keyword">FROM</span> products<br>    <span class="hljs-keyword">WHERE</span> product_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>MySQL执行时会先执行括号内的子查询（内查询），将获得的生菜价格作为结果返回给外查询</p><p>子查询不仅可用在 WHERE …… 中，也可用在 SELECT …… 或 FROM …… 等子句中，本章后面会讲</p><h3 id="IN运算符"><a href="#IN运算符" class="headerlink" title="IN运算符"></a>IN运算符</h3><p>在 sql_store 库 products 表中找出那些从未被订购过的产品</p><p>思路：</p><ul><li>order_items 表里有所有产品被订购的记录，用 DISTINCT 去重，得到所有被订购过的产品列表</li><li>不在这列表里（NOT IN 的使用）的产品即为从未被订购过的产品</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> product_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> product_id<br>    <span class="hljs-keyword">FROM</span> order_items<br>)<br></code></pre></td></tr></table></figure><h3 id="4-子查询-vs-连接"><a href="#4-子查询-vs-连接" class="headerlink" title="4.子查询 vs 连接"></a>4.子查询 vs 连接</h3><p><strong>案例</strong></p><p>上节课的案例，找出从未订购（没有invoices）的顾客：</p><p>法1. 子查询</p><p>先用子查询查出有过发票记录的顾客名单，作为筛选依据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_invoicing;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> clients<br><span class="hljs-keyword">WHERE</span> client_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> client_id<br>    <span class="hljs-comment">/*其实这里加不加DISTINCT对子查询返回的结果有影响</span><br><span class="hljs-comment">    但对最后的结果其实没有影响*/</span><br>    <span class="hljs-keyword">FROM</span> invoices<br>)<br></code></pre></td></tr></table></figure><p>法2. 链接表</p><p>用顾客表 LEFT JOIN 发票记录表，再直接在这个合并详情表中筛选出没有发票记录的顾客</p><p><code>只有合起来，我们才知道顾客有没有发票记录；同时如果使用内链接，会自动把没有发票记录的筛掉</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_invoicing;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> client_id, name …… <br><span class="hljs-comment">-- 不能SELECT DISTINCT *</span><br><span class="hljs-keyword">FROM</span> clients<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> invoices <span class="hljs-keyword">USING</span> (client_id)<br><span class="hljs-comment">-- 注意不能用内链接，否则没有发票记录的顾客（我们的目标）直接就被筛掉了</span><br><span class="hljs-keyword">WHERE</span> invoice_id <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_invoicing;<br><br><span class="hljs-keyword">SELECT</span> <br>    client_id,<br>    <span class="hljs-built_in">SUM</span>(invoice_total) <span class="hljs-keyword">AS</span> total_sales,<br>    <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span><span class="hljs-operator">/</span>invoice_total<span class="hljs-operator">/</span>invoice_date) <span class="hljs-keyword">AS</span> number_of_invoices<br><span class="hljs-keyword">FROM</span> invoices<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> client_id<br><span class="hljs-keyword">HAVING</span> total_sales <span class="hljs-operator">&gt;</span> <span class="hljs-number">500</span> <span class="hljs-keyword">AND</span> number_of_invoices <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span><br><span class="hljs-comment">-- 均为 SELECT 里的列别名</span><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><br><span class="hljs-keyword">SELECT</span> customer_id, first_name, last_name<br><span class="hljs-keyword">FROM</span> customers<br><span class="hljs-keyword">WHERE</span> customer_id <span class="hljs-keyword">IN</span> (<br><span class="hljs-keyword">SELECT</span> customer_id<br><span class="hljs-keyword">FROM</span> orders<br><span class="hljs-keyword">WHERE</span> order_id <span class="hljs-keyword">IN</span> (<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> order_id<br><span class="hljs-keyword">FROM</span> order_items<br><span class="hljs-keyword">WHERE</span> product_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>)<br>)<br><br><span class="hljs-comment">------</span><br><span class="hljs-keyword">SELECT</span> customer_id, first_name, last_name<br><span class="hljs-keyword">FROM</span> customers<br><span class="hljs-keyword">WHERE</span> customer_id <span class="hljs-keyword">IN</span> (<br><span class="hljs-keyword">SELECT</span> customer_id<br><span class="hljs-keyword">FROM</span> orders<br>    <span class="hljs-keyword">JOIN</span> order_items <span class="hljs-keyword">USING</span>(order_id)<br><span class="hljs-keyword">WHERE</span> product_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>)<br><span class="hljs-comment">-------</span><br>USE sql_store;<br><span class="hljs-keyword">SELECT</span> customer_id, first_name, last_name<br><span class="hljs-keyword">FROM</span> customers<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> orders <span class="hljs-keyword">USING</span>(customer_id)<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> order_items <span class="hljs-keyword">USING</span>(order_id)<br><span class="hljs-keyword">WHERE</span> product_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br><br><br></code></pre></td></tr></table></figure><h3 id="5-ALL关键词"><a href="#5-ALL关键词" class="headerlink" title="5. ALL关键词"></a>5. ALL关键词</h3><p><code>&gt; (MAX (……))</code> 和 <code>&gt; ALL(……)</code> 等效可互换</p><p>“比这里面最大的还大” &#x3D; “比这里面的所有的都大”</p><p><strong>案例</strong></p><p>sql_invoicing 库中，选出金额大于3号顾客所有发票金额（或3号顾客最大发票金额） 的发票</p><p>法1. 用MAX关键字</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_invoicing;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> invoices<br><span class="hljs-keyword">WHERE</span> invoice_total <span class="hljs-operator">&gt;</span> (<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(invoice_total)<br>    <span class="hljs-keyword">FROM</span> invoices<br>    <span class="hljs-keyword">WHERE</span> client_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>)<br></code></pre></td></tr></table></figure><p>法2. 用ALL关键字</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_invoicing;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> invoices<br><span class="hljs-keyword">WHERE</span> invoice_total <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALL</span> (<br>    <span class="hljs-keyword">SELECT</span> invoice_total<br>    <span class="hljs-keyword">FROM</span> invoices<br>    <span class="hljs-keyword">WHERE</span> client_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>)<br></code></pre></td></tr></table></figure><p>其实就是把内层括号的MAX拿到了外层括号变成ALL：</p><h3 id="6-ANY关键词"><a href="#6-ANY关键词" class="headerlink" title="6.ANY关键词"></a>6.ANY关键词</h3><p><code>&gt; ANY/SOME(...)</code>与<code>&gt; (MIN(...))</code>等效</p><p><code>=ANY/SOME(...)</code>与<code>IN(...)</code>等效</p><h3 id="7-相关子查询"><a href="#7-相关子查询" class="headerlink" title="7. 相关子查询"></a>7. 相关子查询</h3><p><strong>案例</strong></p><p>选出 sql_hr.employees 里那些工资超过<strong>他所在</strong>办公室平均工资（而不是整体平均工资）的员工<br>关键：如何查询目前主查询员工的所在办公室的平均工资而不是整体的平均工资？<br>思路：给主查询 employees表 设置别名 e，这样在子查询查询平均工资时加上 <code>WHERE office_id = e.office_id</code> 筛选条件即可相关联地查询到目前员工所在地办公室的平均工资</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_hr;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> employees e  <span class="hljs-comment">-- 关键 1</span><br><span class="hljs-keyword">WHERE</span> salary <span class="hljs-operator">&gt;</span> (<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary)<br>    <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-keyword">WHERE</span> office_id <span class="hljs-operator">=</span> e.office_id  <span class="hljs-comment">-- 关键 2</span><br>    <span class="hljs-comment">-- 【子查询表字段不用加前缀，主查询表的字段要加前缀，以此区分】</span><br>)<br></code></pre></td></tr></table></figure><p>之前都是非关联主&#x2F;子（外&#x2F;内）查询，比如子查询先查出整体的某平均值或满足某些条件的一列id，作为主查询的筛选依据，这种子查询与主查询无关，会先一次性得出查询结果再返回给主查询供其使用。</p><p>而下面这种相关联子查询例子里，子查询要查询的是某员工所在办公室的平均值，子查询是依赖主查询的，<strong>注意这种关联查询是在主查询的每一行&#x2F;每一条记录层面上依次进行的</strong>，这一点可以为我们写关联子查询提供线索（注意表别名的使用），另外也正因为这一点，相关子查询会比非关联查询执行起来慢一些。</p><h3 id="8-EXISTS-运算符"><a href="#8-EXISTS-运算符" class="headerlink" title="8.EXISTS 运算符"></a>8.EXISTS 运算符</h3><p><code>IN + 子查询</code> 等效于 <code>EXIST + 相关子查询</code>，如果前者子查询的结果集过大占用内存，用后者逐条验证更有效率。另外 EXIST() 本质上是根据是否为空返回 TRUE 和 FALSE，所以也可以加 NOT 取反。</p><p><strong>案例</strong></p><p>找出有过发票记录的客户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_invoicing;<br><br><span class="hljs-keyword">SELECT</span> <br>    client_id,<br>    <span class="hljs-built_in">SUM</span>(invoice_total) <span class="hljs-keyword">AS</span> total_sales,<br>    <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span><span class="hljs-operator">/</span>invoice_total<span class="hljs-operator">/</span>invoice_date) <span class="hljs-keyword">AS</span> number_of_invoices<br><span class="hljs-keyword">FROM</span> invoices<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> client_id<br><span class="hljs-keyword">HAVING</span> total_sales <span class="hljs-operator">&gt;</span> <span class="hljs-number">500</span> <span class="hljs-keyword">AND</span> number_of_invoices <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span><br><span class="hljs-comment">-- 均为 SELECT 里的列别名</span><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_invoicing;<br><br><span class="hljs-keyword">SELECT</span> <br>    client_id,<br>    <span class="hljs-built_in">SUM</span>(invoice_total) <span class="hljs-keyword">AS</span> total_sales,<br>    <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span><span class="hljs-operator">/</span>invoice_total<span class="hljs-operator">/</span>invoice_date) <span class="hljs-keyword">AS</span> number_of_invoices<br><span class="hljs-keyword">FROM</span> invoices<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> client_id<br><span class="hljs-keyword">HAVING</span> total_sales <span class="hljs-operator">&gt;</span> <span class="hljs-number">500</span> <span class="hljs-keyword">AND</span> number_of_invoices <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span><br><span class="hljs-comment">-- 均为 SELECT 里的列别名</span><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_invoicing;<br><br><span class="hljs-keyword">SELECT</span> <br>    client_id,<br>    <span class="hljs-built_in">SUM</span>(invoice_total) <span class="hljs-keyword">AS</span> total_sales,<br>    <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span><span class="hljs-operator">/</span>invoice_total<span class="hljs-operator">/</span>invoice_date) <span class="hljs-keyword">AS</span> number_of_invoices<br><span class="hljs-keyword">FROM</span> invoices<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> client_id<br><span class="hljs-keyword">HAVING</span> total_sales <span class="hljs-operator">&gt;</span> <span class="hljs-number">500</span> <span class="hljs-keyword">AND</span> number_of_invoices <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span><br><span class="hljs-comment">-- 均为 SELECT 里的列别名</span><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_invoicing;<br><br><span class="hljs-keyword">SELECT</span> <br>    client_id,<br>    <span class="hljs-built_in">SUM</span>(invoice_total) <span class="hljs-keyword">AS</span> total_sales,<br>    <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span><span class="hljs-operator">/</span>invoice_total<span class="hljs-operator">/</span>invoice_date) <span class="hljs-keyword">AS</span> number_of_invoices<br><span class="hljs-keyword">FROM</span> invoices<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> client_id<br><span class="hljs-keyword">HAVING</span> total_sales <span class="hljs-operator">&gt;</span> <span class="hljs-number">500</span> <span class="hljs-keyword">AND</span> number_of_invoices <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span><br><span class="hljs-comment">-- 均为 SELECT 里的列别名</span><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># way1: 子查询<br>USE sql_invoicing;<br>SELECT *<br>FROM client<br>WHERE client_id IN (<br>SELECT DISTINCT client_id<br>FROM invoices<br>)<br># way2：链接表<br>USE sql_invoicing;<br>SELECT DISTINCT client_id, name, ...<br>FROM clients<br>JOIN invoices USING(client_id)<br><br>#EXISTS运算符<br>USE sql_invoicing;<br><br>SELECT *<br>FROM clients c<br>WHERE EXISTS (<br>    SELECT */client_id  <br>    /* 就这个子查询的目的来说，SELECT的选择不影响结果，<br>    因为EXISTS()函数只根据是否为空返回 TRUE 和 FALSE */<br>    FROM invoices<br>    WHERE client_id = c.client_id<br>)<br></code></pre></td></tr></table></figure><p>这还是个相关子查询，因为在其中引用了主查询的 clients 表。这同样是按照主查询的记录一条条验证执行的。具体说来，对于 clients 表（设置别名为 c）里的每一个顾客，子查询在 invoices 表查找这个人的发票记录（ 即 client_id &#x3D; c.client_id 的发票记录），有就返回相关记录否者返回空，然后 EXISTS() 根据是否为空得到 TRUE 和 FALSE（表示此人有无发票记录），然后主查询凭此确定是否保留此条记录。</p><h3 id="9-SELECT字句的子查询"><a href="#9-SELECT字句的子查询" class="headerlink" title="9. SELECT字句的子查询"></a>9. SELECT字句的子查询</h3><p>不仅 WHERE 筛选条件里可以用子查询，SELECT 选择子句和 FROM 来源表子句也能用子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_invoicing;<br><br><span class="hljs-keyword">SELECT</span> <br>    invoice_id,<br>    invoice_total,<br>    (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(invoice_total) <span class="hljs-keyword">FROM</span> invoices) <span class="hljs-keyword">AS</span> invoice_average,<br>    <span class="hljs-comment">/*不能直接用聚合函数，因为“比较强势”，会压缩聚合结果为一条</span><br><span class="hljs-comment">    用括号+子查询(SELECT AVG(invoice_total) FROM invoices) </span><br><span class="hljs-comment">    将其作为一个数值结果 152.388235 加入主查询语句*/</span><br>    invoice_total <span class="hljs-operator">-</span> (<span class="hljs-keyword">SELECT</span> invoice_average) <span class="hljs-keyword">AS</span> difference<br>    <span class="hljs-comment">/*SELECT表达式里要用原列名，不能直接用别名invoice_average</span><br><span class="hljs-comment">    要用列别名的话用子查询（SELECT 同级的列别名）即可</span><br><span class="hljs-comment">    说真的，感觉这个子查询有点难以理解，但记住会用就行*/</span><br><span class="hljs-keyword">FROM</span> invoices<br></code></pre></td></tr></table></figure><p><strong>练习</strong></p><p>得到一个有如下列的表格：client_id, name, total_sales（各个客户的发票总额）, average（总平均发票额）, difference（前两个值的差）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_invoicing;<br><br><span class="hljs-keyword">SELECT</span> <br>client_id,<br>name,<br>(<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(invoice_total) <span class="hljs-keyword">FROM</span> invoices <span class="hljs-keyword">WHERE</span> client_id <span class="hljs-operator">=</span> c.client_id ) <span class="hljs-keyword">AS</span> total_sales,<br>(<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(invoice_total) <span class="hljs-keyword">FROM</span> invoices) <span class="hljs-keyword">AS</span> average,<br>(<span class="hljs-keyword">SELECT</span> total_sales <span class="hljs-operator">-</span> average) <span class="hljs-keyword">AS</span> difference<br><span class="hljs-keyword">FROM</span> clients c<br>    <br><span class="hljs-keyword">FROM</span> client c<br></code></pre></td></tr></table></figure><h3 id="10-FROM字句的子查询"><a href="#10-FROM字句的子查询" class="headerlink" title="10. FROM字句的子查询"></a>10. FROM字句的子查询</h3><p>子查询的结果同样可以充当一个“虚拟表”作为FROM语句中的来源表，即将筛选查询结果作为来源再进行进一步的筛选查询。但注意只有在子查询不太复杂时进行这样的嵌套，否则最好用后面讲的视图先把子查询结果储存起来再使用。</p><p><strong>案例</strong></p><p>将上一节练习里的查询结果当作来源表，查询其中 total_sales 非空的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_invoicing;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span> (<br>    <span class="hljs-keyword">SELECT</span> <br>        client_id,<br>        name,<br>        (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(invoice_total) <span class="hljs-keyword">FROM</span> invoices <span class="hljs-keyword">WHERE</span> client_id <span class="hljs-operator">=</span> c.client_id) <span class="hljs-keyword">AS</span> total_sales,<br>        (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(invoice_total) <span class="hljs-keyword">FROM</span> invoices) <span class="hljs-keyword">AS</span> average,<br>        (<span class="hljs-keyword">SELECT</span> total_sales <span class="hljs-operator">-</span> average) <span class="hljs-keyword">AS</span> difference   <br>    <span class="hljs-keyword">FROM</span> clients c<br>) <span class="hljs-keyword">AS</span> sales_summury #necessary·<br><span class="hljs-comment">/* 在FROM中使用子查询，即使用 “派生表” 时，</span><br><span class="hljs-comment">必须给派生表取个别名（不管用不用），这是硬性要求，不写会报错：</span><br><span class="hljs-comment">Error Code: 1248. Every derived table（派生表、导出表）</span><br><span class="hljs-comment">must have its own alias */</span><br><span class="hljs-keyword">WHERE</span> total_sales <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br></code></pre></td></tr></table></figure><h2 id="【第七章】MySQL的基本函数"><a href="#【第七章】MySQL的基本函数" class="headerlink" title="【第七章】MySQL的基本函数"></a>【第七章】MySQL的基本函数</h2><h2 id="1-数值函数"><a href="#1-数值函数" class="headerlink" title="1. 数值函数"></a>1. 数值函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ROUND(<span class="hljs-number">5.7365</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment">-- 四舍五入</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">TRUNCATE</span>(<span class="hljs-number">5.7365</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment">-- 截断</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">CEILING</span>(<span class="hljs-number">5.2</span>)  <span class="hljs-comment">-- 天花板函数，大于等于此数的最小整数</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">5.6</span>)  <span class="hljs-comment">-- 地板函数，小于等于此数的最大整数</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">ABS</span>(<span class="hljs-number">-5.2</span>)  <span class="hljs-comment">-- 绝对值</span><br><span class="hljs-keyword">SELECT</span> RAND()  <span class="hljs-comment">-- 随机函数，0到1的随机值</span><br></code></pre></td></tr></table></figure><h2 id="2-字符串函数"><a href="#2-字符串函数" class="headerlink" title="2. 字符串函数"></a>2. 字符串函数</h2><ol><li>LENGTH, UPPER, LOWER</li><li>TRIM, LTRIM, RTRIM</li><li>LEFT, RIGHT, SUBSTRING</li><li>LOCATE, REPLACE, 【CONCAT】</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 长度、转大小写：</span><br><span class="hljs-keyword">SELECT</span> LENGTH(<span class="hljs-string">&#x27;sky&#x27;</span>)  <span class="hljs-comment">-- 字符串字符个数/长度（LENGTH）</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">UPPER</span>(<span class="hljs-string">&#x27;sky&#x27;</span>)  <span class="hljs-comment">-- 转大写</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">LOWER</span>(<span class="hljs-string">&#x27;Sky&#x27;</span>)  <span class="hljs-comment">-- 转小写</span><br><br><span class="hljs-comment">-- 处理/修剪（trim）字符串前后的空格，L、R 表示 LEFT、RIGHT：</span><br><span class="hljs-keyword">SELECT</span> LTRIM(<span class="hljs-string">&#x27;  Sky&#x27;</span>)<br><span class="hljs-keyword">SELECT</span> RTRIM(<span class="hljs-string">&#x27;Sky  &#x27;</span>)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">TRIM</span>(<span class="hljs-string">&#x27; Sky &#x27;</span>)<br><br><span class="hljs-comment">-- 切片</span><br><span class="hljs-comment">-- 取左边，取右边，取中间</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">LEFT</span>(<span class="hljs-string">&#x27;Kindergarden&#x27;</span>, <span class="hljs-number">4</span>)  <span class="hljs-comment">-- 取左边（LEFT）4个字符</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">RIGHT</span>(<span class="hljs-string">&#x27;Kindergarden&#x27;</span>, <span class="hljs-number">6</span>)  <span class="hljs-comment">-- 取右边（RIGHT）6个字符</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUBSTRING</span>(<span class="hljs-string">&#x27;Kindergarden&#x27;</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>)  <br><span class="hljs-comment">-- 取中间从第7个开始的长度为6的子串（SUBSTRING）</span><br><span class="hljs-comment">-- 注意是从第1个（而非第0个）开始计数的</span><br><span class="hljs-comment">-- 省略第3参数（子串长度）则一直截取到最后</span><br><br><span class="hljs-comment">-- 定位</span><br><span class="hljs-keyword">SELECT</span> LOCATE(<span class="hljs-string">&#x27;gar&#x27;</span>, <span class="hljs-string">&#x27;Kindergarden&#x27;</span>)  <span class="hljs-comment">-- 定位（LOCATE）首次出现的位置</span><br><span class="hljs-comment">-- 没有的话返回0（其他编程语言大多返回-1，可能因为索引是从0开始的）</span><br><span class="hljs-comment">-- 这个定位/查找函数依然是不区分大小写的</span><br><br><span class="hljs-comment">-- 替换：</span><br><span class="hljs-keyword">SELECT</span> REPLACE(<span class="hljs-string">&#x27;Kindergarten&#x27;</span>, <span class="hljs-string">&#x27;garten&#x27;</span>, <span class="hljs-string">&#x27;garden&#x27;</span>)<br><br><span class="hljs-comment">-- 连接：</span><br>USE sql_store;<br><br><span class="hljs-keyword">SELECT</span> CONCAT(first_name, <span class="hljs-string">&#x27; &#x27;</span>, last_name) <span class="hljs-keyword">AS</span> full_name<br><span class="hljs-comment">-- concatenate v. 连接</span><br><span class="hljs-keyword">FROM</span> customers<br></code></pre></td></tr></table></figure><h2 id="3-MySQL中的日期函数"><a href="#3-MySQL中的日期函数" class="headerlink" title="3. MySQL中的日期函数"></a>3. MySQL中的日期函数</h2><ol><li>NOW, CURDATE, CURTIME</li><li>YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, DAYNAME, MONTHNAME</li><li>EXTRACT(单位 FROM 日期时间对象)， 如 EXTRACT(YEAR FROM NOW())</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 当前时间</span><br><span class="hljs-keyword">SELECT</span> NOW()  <span class="hljs-comment">-- 2020-09-12 08:50:46</span><br><span class="hljs-keyword">SELECT</span> CURDATE()  <span class="hljs-comment">-- current date, 2020-09-12</span><br><span class="hljs-keyword">SELECT</span> CURTIME()  <span class="hljs-comment">-- current time, 08:50:46</span><br><br><span class="hljs-comment">-- 提取时间日期对象中的元素</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">YEAR</span>(NOW())  <span class="hljs-comment">-- 2020</span><br><span class="hljs-comment">-- 还有MONTH, DAY, HOUR, MINUTE, SECOND</span><br><br><span class="hljs-keyword">SELECT</span> DAYNAME(NOW())  <span class="hljs-comment">-- Saturday</span><br><span class="hljs-keyword">SELECT</span> MONTHNAME(NOW())  <span class="hljs-comment">-- September</span><br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">EXTRACT</span>(<span class="hljs-keyword">YEAR</span> <span class="hljs-keyword">FROM</span> NOW())<br><span class="hljs-comment">-- EXTRACT(单位 FROM 日期时间对象)</span><br></code></pre></td></tr></table></figure><h2 id="4-格式化日期和时间"><a href="#4-格式化日期和时间" class="headerlink" title="4. 格式化日期和时间"></a>4. 格式化日期和时间</h2><p><code>DATE_FORMAT(date, format)</code> 将 date 根据 format 字符串进行格式化。</p><p><code>TIME_FORMAT(time, format)</code> 类似于 DATE_FORMAT 函数，但这里 format 字符串只能包含用于小时，分钟，秒和微秒的格式说明符。其他说明符产生一个 NULL 值或0。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> DATE_FORMAT(NOW(), <span class="hljs-string">&#x27;%M %d, %Y&#x27;</span>)  <span class="hljs-comment">-- September 12, 2020</span><br><span class="hljs-comment">-- 格式说明符里，大小写是不同的，这是目前SQL里第一次出现大小写不同的情况</span><br><span class="hljs-keyword">SELECT</span> TIME_FORMAT(NOW(), <span class="hljs-string">&#x27;%H:%i %p&#x27;</span>)  <span class="hljs-comment">-- 11:07 AM</span><br></code></pre></td></tr></table></figure><h2 id="5-计算日期和时间"><a href="#5-计算日期和时间" class="headerlink" title="5. 计算日期和时间"></a>5. 计算日期和时间</h2><p>有时需要对日期事件对象进行运算，如增加一天或算两个时间的差值之类，介绍一些最有用的日期时间计算函数：</p><ol><li>DATE_ADD, DATE_SUB</li><li>DATEDIFF</li><li>TIME_TO_SEC</li></ol><p>增加或减少一定的天数、月数、年数、小时数等等</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> DATE_ADD(NOW(), <span class="hljs-type">INTERVAL</span> <span class="hljs-number">-1</span> <span class="hljs-keyword">DAY</span>)<br><span class="hljs-keyword">SELECT</span> DATE_SUB(NOW(), <span class="hljs-type">INTERVAL</span> <span class="hljs-number">1</span> <span class="hljs-keyword">YEAR</span>)<br></code></pre></td></tr></table></figure><p>计算日期差异</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> DATEDIFF(<span class="hljs-string">&#x27;2019-01-01 09:00&#x27;</span>, <span class="hljs-string">&#x27;2019-01-05&#x27;</span>)  <span class="hljs-comment">-- -4</span><br><span class="hljs-comment">-- 会忽略时间部分，只算日期差异</span><br><br><span class="hljs-comment">-- 借助 TIME_TO_SEC 函数计算时间差异</span><br><span class="hljs-comment">-- TIME_TO_SEC：计算从 00:00 到某时间经历的秒数</span><br><br><span class="hljs-keyword">SELECT</span> TIME_TO_SEC(<span class="hljs-string">&#x27;09:00&#x27;</span>)  <span class="hljs-comment">-- 32400</span><br><span class="hljs-keyword">SELECT</span> TIME_TO_SEC(<span class="hljs-string">&#x27;09:00&#x27;</span>) <span class="hljs-operator">-</span> TIME_TO_SEC(<span class="hljs-string">&#x27;09:02&#x27;</span>)  <span class="hljs-comment">-- -120</span><br></code></pre></td></tr></table></figure><h2 id="6-IFNULL和COALESCE函数"><a href="#6-IFNULL和COALESCE函数" class="headerlink" title="6. IFNULL和COALESCE函数"></a>6. IFNULL和COALESCE函数</h2><p>两个用来替换空值的函数：IFNULL, COALESCE. 后者更灵活</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><span class="hljs-keyword">SELECT</span><br>order_id,<br>IFNULL(shipper_id,<span class="hljs-string">&#x27;Not Assigned&#x27;</span>) <span class="hljs-keyword">AS</span> shipper<br><span class="hljs-keyword">FROM</span> orders<br> <span class="hljs-comment">/* If expr1 is not NULL, IFNULL() returns expr1; </span><br><span class="hljs-comment">    otherwise it returns expr2. */</span><br>    <br>USE sql_store;<br><span class="hljs-keyword">SELECT</span> <br>    order_id,<br>    <span class="hljs-built_in">COALESCE</span>(shipper_id, comments, <span class="hljs-string">&#x27;Not Assigned&#x27;</span>) <span class="hljs-keyword">AS</span> shipper<br>    <span class="hljs-comment">/* Returns the first non-NULL value in the list, </span><br><span class="hljs-comment">    or NULL if there are no non-NULLvalues. */</span><br>    <span class="hljs-comment">-- COALESCE 函数是返回一系列值中的首个非空值，更灵活</span><br><span class="hljs-keyword">FROM</span> orders   <br></code></pre></td></tr></table></figure><h2 id="7-IF函数"><a href="#7-IF函数" class="headerlink" title="7. IF函数"></a>7. IF函数</h2><p><code>IF(条件表达式, 返回值1, 返回值2)</code> 返回值可以是任何东西，数值 文本 日期时间 空值null 均可</p><p><strong>练习</strong></p><p>得到包含如下字段的表：</p><ol><li>product_id</li><li>name (产品名称)</li><li>orders (该产品出现在订单中的次数)</li><li>frequency (根据是否多于一次而分类为’Once’或’Many times’)</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><span class="hljs-keyword">SELECT</span> <br>product_id,<br>    name,<br>    <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> orders,<br>    IF(<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<span class="hljs-operator">=</span><span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Once&#x27;</span>,<span class="hljs-string">&#x27;Many times&#x27;</span>) <span class="hljs-keyword">AS</span> frequency<br><span class="hljs-keyword">FROM</span> products  <br><span class="hljs-keyword">JOIN</span> order_items <span class="hljs-keyword">USING</span>(product_id)<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> product_id<br><br><span class="hljs-comment">-- 注意：先分组(group by)再计数(count)</span><br></code></pre></td></tr></table></figure><h2 id="8-CASE运算符"><a href="#8-CASE运算符" class="headerlink" title="8. CASE运算符"></a>8. CASE运算符</h2><p>当分类多余两种时，可以用IF嵌套，也可以用CASE语句，后者可读性更好</p><p>CASE语句结构：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CASE</span> <br>    <span class="hljs-keyword">WHEN</span> …… <span class="hljs-keyword">THEN</span> ……<br>    <span class="hljs-keyword">WHEN</span> …… <span class="hljs-keyword">THEN</span> ……<br>    <span class="hljs-keyword">WHEN</span> …… <span class="hljs-keyword">THEN</span> ……<br>    ……<br>    [<span class="hljs-keyword">ELSE</span> ……] （<span class="hljs-keyword">ELSE</span>子句是可选的）<br><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><p><strong>练习</strong></p><p>得到包含如下字段的表：customer, points, category（根据积分 &lt;2k、2k~3k（包含两端）、&gt;3k 分为青铜、白银和黄金用户）</p><p>之前也是用过 UNION 法，分别查询增加分类字段再合并，很麻烦。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE sql_store;<br><span class="hljs-keyword">SELECT</span> <br>CONCAT(first_name,<span class="hljs-string">&#x27;&#x27;</span>,last_name) <span class="hljs-keyword">AS</span> customer,<br>points,<br><span class="hljs-keyword">CASE</span><br><span class="hljs-keyword">WHEN</span> points <span class="hljs-operator">&lt;</span> <span class="hljs-number">2000</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;Bronze&#x27;</span><br>        <span class="hljs-keyword">WHEN</span> points <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">2000</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">3000</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;Silver&#x27;</span><br>        <span class="hljs-keyword">WHEN</span> points <span class="hljs-operator">&gt;</span> <span class="hljs-number">3000</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;Gold&#x27;</span><br>    <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> category<br><span class="hljs-keyword">FROM</span> customers<br><span class="hljs-keyword">ORDER</span>  <span class="hljs-keyword">BY</span> points <span class="hljs-keyword">DESC</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据科学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>泛函分析</title>
    <link href="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/"/>
    <url>/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>十遍实变 泛函心寒</p>          </div><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-1b32e2208f1af2722a9ff6eca04c2433_b.jpg" alt="小狗自闭"></p><span id="more"></span><h1 id="度量空间"><a href="#度量空间" class="headerlink" title="度量空间"></a><strong>度量空间</strong></h1><h2 id="度量空间的定义与举例"><a href="#度量空间的定义与举例" class="headerlink" title="度量空间的定义与举例"></a><strong>度量空间的定义与举例</strong></h2><ul><li><p>度量空间  设$X $为一非空集合. 若存在二元映射 $d:X×X→R$, 使得$∀x,y,z∈X$， 满足以下三个条件： </p><p>1)非负性：且当且仅当$d(x,y)≥0$, 且$d(x,y)&#x3D;0$当且仅当$x&#x3D;y $</p><p>2)对称性: $d(x,y)&#x3D;d(y,x)$ </p><p>3)三角不等式: $d(x,y)≤d(x,z)+d(z,y)$ </p><p>则称$d$为$X$上的一个距离函数，称$d(x,y)$为$x$和$y$两点间的距离  </p></li><li><p>example： </p><p>欧式空间$R^n: d(x,y)&#x3D;∑_{i&#x3D;1}^n(x_i−y_i)^2$ </p><p>Schwarz表达式：$\sum \limits_{i&#x3D;1}^na_ib_i\leq(\sum\limits_{i&#x3D;1}^na_i^2)^{\frac{1}{2}}(\sum\limits_{i&#x3D;1}^nb_i^2)^{\frac{1}{2}}$</p></li><li><p>进一步有Holder不等式$\sum \limits_{i&#x3D;1}^n|a_ib_i|\leq(\sum\limits_{i&#x3D;1}^n|a_i|^p)^{\frac{1}{p}}(\sum\limits_{i&#x3D;1}^n|b_i^q|)^{\frac{1}{q}}$，$\int _{i&#x3D;1}^n|f(x)g(x)|dx\leq(\int _{i&#x3D;1}^n|f(x)|^pdx)^{\frac{1}{p}}(\int _{i&#x3D;1}^n|g(x)^q|dx)^{\frac{1}{q}}$其中且$p,q&gt;1$且$\frac{1}{p}+\frac{1}{q}&#x3D;1$</p></li><li><p>Minkowski不等式：$\left[\sum \limits_{i&#x3D;1}^n(a_i+b_i)^2\right]^{\frac{1}{2}}\leq(\sum\limits_{i&#x3D;1}^na_i^2)^{\frac{1}{2}}+(\sum\limits_{i&#x3D;1}^nb_i^2)^{\frac{1}{2}}$，$\left[\sum \limits_{i&#x3D;1}^n(a_i+b_i)^k\right]^{\frac{1}{k}}\leq(\sum\limits_{i&#x3D;1}^na_i^k)^{\frac{1}{k}}+(\sum\limits_{i&#x3D;1}^nb_i^k)^{\frac{1}{k}}$，$\left[\int_{E}|f(x)+g(x)|^kdx\right]^{\frac{1}{k}}\leq(\int_{E}|f(x)|^kdx)^{\frac{1}{k}}+(\int_{E}|g(x)|^kdx)^{\frac{1}{k}},k\geq 1$</p></li><li><p>离散度量空间$X$：设$X$为非空集合，$∀x,y∈X$, 定义距离<br>$$<br>d_0(x,y)&#x3D;\begin{cases}0,x&#x3D;y\1,x\neq y\end{cases}<br>$$</p></li><li><p>连续函数空间C[a,b]: $d(f,g)&#x3D;\max\limits_{t\in[a,b]}|f(t)-g(t)|$</p></li><li><p>有界数列空间$l_∞$: 记$l^{\infty}&#x3D;{x&#x3D;(x_1,x_2,\cdots,x_n,\cdots)&#x3D;(x_i)|\sup\limits_{i\geq 1}{|x_i|}&lt;\infty}$，$d(x,y)&#x3D;\sup\limits_{i\geq 1}|x_i-y_i|$</p></li><li><p>p次幂可和的数列空间$l_p$: 记其中$l^{p}&#x3D;{x&#x3D;(x_1,x_2,\cdots,x_n,\cdots)&#x3D;(x_i)|\sup\limits_{i\geq 1}{|x_i|^p}&lt;\infty},其中1\leq p&lt; \infty$，$d(x,y)&#x3D;\left(\sum\limits_{i&#x3D; 1}^{\infty}|x_i-y_i|^p\right)^{\frac{1}{p}}$</p></li></ul><h2 id="度量空间的拓扑性质"><a href="#度量空间的拓扑性质" class="headerlink" title="度量空间的拓扑性质"></a><strong>度量空间的拓扑性质</strong></h2><ul><li><p>领域 $O(x_0,\delta)&#x3D;{x|d(x,x_0)&lt;\delta,x\in X}$</p></li><li><p>内点、开集与闭集 </p></li><li><p>内点：  $x_0\in G\subset X,若\exists O(x_0,\delta)\subset G,则称x_0为G的内点$</p></li><li><p>开集的性质</p></li><li><p>闭集的性质</p></li><li><p>聚点与闭包 </p><p>聚点：$x_0的任意\delta 领域O(x_0,\delta)含有A异于x_0的点 $</p><p>$导集A’：A的全体聚点所构成的集合$</p><p>闭包：$\overline{A}&#x3D;A\cup A’$</p><p>设$ (X,d)  $是度量空间，$ x_0\in X,A\subset X$ </p><ol><li>$x_0\in A’\iff  \exists 元素互不相同点列{x_n}\subset A,使\lim\limits_{n\rightarrow \infty}  x_n&#x3D;x_0$</li><li>$\overline{A}$是闭集</li><li>$A$是闭集$\iff A&#x3D;\overline{A}$</li><li>若 $\exists $闭集 $F\subset X$,使得 $A\subset F$, 则$A\subset \overline{A}\subset F$</li></ol></li><li><p>拓扑空间 </p><p>设$X$是非空集合，如果 $\tau$ 是$X$的一个子集族，且满足</p><ol><li>$\oslash,X\in \tau$</li><li>$\tau 的任意多个集合的并仍属于 \tau$</li><li>$\tau$的任意两个集合的交仍属于$\tau$则称子集族 $ \tau $为 $X$ 的拓扑， $(X,\tau)$ 为一个拓扑空间,   $\tau$内的集合为拓扑空间的开集</li></ol></li><li><p>领域和闭集</p><p>领域：$(X,\tau),x\in X$, $U$是$X$的子集族,若$\exists G\in \tau$,使$x\in G\subset U $</p><p>开集：  $U$是开集当且仅当$U$是它的每一点的领域</p></li><li><p>离散拓扑空间：离散度量空间的任意非空子集既是开集又是闭集 </p></li><li><p>闭集的性质</p><p>Hausdorff空间：设$X$是一个拓扑空间，如果$X$中任意两个不同的点都有不相交的领域，则称$X$为Hausdorff空间</p></li></ul><blockquote><p><em>度量空间$(X,d)$诱导的拓扑空间是Hausdorff空间</em></p></blockquote><h2 id="度量空间中的极限与连续"><a href="#度量空间中的极限与连续" class="headerlink" title="度量空间中的极限与连续"></a><strong>度量空间中的极限与连续</strong></h2><ul><li><p>点列的极限</p><p>极限的性质：<br>1.若点列$ {x_n}$收敛，则其极限唯一 </p><p>2.若点列$  x_n\rightarrow x_0$，则${x_n}$的任何子列$x_{n_k}\rightarrow x_0 $</p><p>3.收敛子列有界    </p></li><li><p>子空间与集合的直径</p><p>$·d(x,A)&#x3D;\inf\limits_{y\in A}{d(x,y)}$<br>·集合的直径$ diaA&#x3D;\sup\limits_{x,y\in A}{d(x,y)} $<br>(有限集：$diaA$为有限值)</p></li><li><p>连续与一致连续</p><p>连续： 关于$x_0\in X$,如果$\forall \epsilon &gt;0,\exists \delta&gt;0$, 当$x\in X$且$d(x,x_0)&lt;\delta $有$\rho(f(x),f(x_0))&lt;\epsilon$</p><p>一致连续 ： $\forall \epsilon &gt;0,\exists \delta&gt;0$, $\forall x,y\in X$且$d(x,y)&lt;\delta $有$\rho(f(x),f(y))&lt;\epsilon$</p></li><li><p>连续的等价条件</p><ol><li>任一点点连续</li><li>$ \forall O(f(x_0),\epsilon ),\exists O(x_0,\delta)$,使$f(O(x_0,\delta))\subset O(f(x_0),\epsilon )$</li><li>连续点列映成连续点列</li><li>开集的原像是开集</li></ol></li></ul><h2 id="度量空间的可分性"><a href="#度量空间的可分性" class="headerlink" title="度量空间的可分性"></a><strong>度量空间的可分性</strong></h2><ul><li>稠密</li><li>稠密集的传递性</li><li>可分的度量空间 </li><li>证明可分</li><li>可分的子空间</li></ul><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-bcb95f7adecd93604beebfc784723da0_1440w.png" alt="img"></p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-55f9b5ab110b8603fa1bb7bd42cdf074_1440w.png" alt="img"></p><h2 id="度量空间的完备性"><a href="#度量空间的完备性" class="headerlink" title="度量空间的完备性"></a><strong>度量空间的完备性</strong></h2><ul><li>基本列</li><li>性质</li><li>完备的度量空间</li></ul><blockquote><p> 设$(X,d)$是度量空间，$M⊂X$, 若$M$中的任何基本列都收敛, 且收敛点属于$M$，则称$M$是度量空间$X$的完备集.若$X$是完备集，则称$X$是完备的度量空间.</p></blockquote><ul><li>闭球套定理(类似实数完备集的区间套) </li><li>同构映射与同构空间 </li><li>完备化定理</li></ul><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-454e8cc078fb16086ce7628ac75a89f1_1440w.png" alt="img"></p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-0793ac3dd065ca7876fe2478e621ca7f_1440w.png" alt="img"></p><h2 id="度量空间的紧集"><a href="#度量空间的紧集" class="headerlink" title="度量空间的紧集"></a>度量空间的紧集</h2><ul><li>列紧集、紧集与紧空间</li></ul><blockquote><ol><li>设是度量空间，$A\subset X$，如果A中任何点列都有收敛于的子列，则称为列紧集  </li><li>紧集&#x3D;列紧集+闭集 </li><li>本身是列紧集(必是闭集)则称为紧空间</li></ol></blockquote><ul><li>$设(X,d)是度量空间，A⊂X，则A是紧集当且仅当∀x_n⊂A，存在子列x_{n_k}收敛且lim_{k→∞}x_{n_k}&#x3D;x_0∈A$</li><li>设$(X,d)是度量空间，A⊂X$，下列命题成立：</li></ul><blockquote><ul><li>任何有限集必是紧集. </li><li>列紧集的子集是列紧集 </li><li>任何多个列紧集的交是列紧集；有限多个列紧集的并是列紧集 </li><li>列紧集必是有界集，反之不真 </li><li>$A$是$X$的列紧集当且仅当它的闭包$\bar{A}$是紧集</li></ul></blockquote><ul><li><p>$ 设X为紧空间，A⊂X，则$</p><p>1)紧空间是有界空间 </p><p>2)紧空间是完备的度量空间 </p><p>3)A是紧集当且仅当A是闭集</p></li><li><p>列紧集与紧集在$R^n$的特性：<br> 设$A$是$n$维欧氏空间$R^n$的一个子集，那么<br> 1)A是列紧集当且仅当A是有界集<br> 2)A是紧集当且仅当A是有界闭集</p></li><li><p>连续映射将紧集映射为紧集：<br>$设f是从度量空间(X,d)到(Y,ρ)上的连续映射，A是X中的紧集，那么f(A)是Y中的紧集$</p><ul><li><strong>最值定理</strong>：设是度量空间中的紧集，是定义在上的实值连续函数(这里的映射也称为泛函)，即, 那么在上能取到最大值与最小值</li></ul></li></ul><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-cc245756dbc08c5de516c30de6aea815_1440w.png" alt="img"></p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-520325fbf0ac50b7ba7338d423d9489f_1440w.png" alt="img"></p><h2 id="度量空间中的全有界集"><a href="#度量空间中的全有界集" class="headerlink" title="度量空间中的全有界集"></a>度量空间中的全有界集</h2><ul><li><p>网：$设X是度量空间，A,B\subset X. 给定\epsilon&gt;0, 如果对于B中任何点x, 必存在A中点x’，使得d(x,x’)&lt;\epsilon,  则称A是B的一个网，即B\subset \cup_{x\in A}O(x,\epsilon). $</p></li><li><p>全有界集：</p><p>$设X是度量空间，A⊂X. 如果对于任给的ϵ&gt;0, A总存在<strong>有限的</strong>ϵ<strong>网</strong>, 则称A是B的一个全有界集. $</p><p>$设X是度量空间，A⊂X，如果A是全有界集，则 1)A是有界集 2)A是可分集$</p><p>$全有界集的充要条件：设X是度量空间，A⊂X，则A是全有界集当且仅当A中的任何点列必有基本子列 $</p></li><li><p><strong>Hausdorff定理</strong>：$设X$是度量空间，$A⊂X$. 下列结论成立： 1)若$A$是列紧集，则$A$是全有界集 2)若$X$是完备的度量空间，则$A$是列紧集当且仅当$A$是全有界集</p></li></ul><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-285c5de76449197b97b1d188594f0765_1440w.jpg" alt="img"></p><ul><li><p>$设X$是度量空间，$A$是$X$的紧子集. 则$A$的任何子集均是有界集，也是可分集 </p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-dc93c26bd6b2689feee347e3e221223b_1440w-169893739957454.png" alt="img"><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-03c1ce01393c465a1d6b3ce6b18fb264_1440w.png" alt="img"></p></li></ul><blockquote><p><em>注意列紧集 全有界集 可分集的定义和子列的性质都有或多或少的联系</em></p></blockquote><h2 id="度量空间中的开覆盖"><a href="#度量空间中的开覆盖" class="headerlink" title="度量空间中的开覆盖"></a>度量空间中的开覆盖</h2><blockquote><p><em>开覆盖很重要的意义是从另外一个角度刻画紧集：任意开覆盖有有限子覆盖</em></p></blockquote><ul><li>开覆盖：设$X$是度量空间, $Λ$ 为一指标集, $A⊂X$,$∀λ∈Λ,G_λ$ 是$X$的开子集, 如果 $A⊂⋃_{λ∈Λ}G_λ$, 则称${G_λ∣λ∈Λ}$ 是$A$的开覆盖.</li><li>设$X$是度量空间, $A$是$X$的紧子集,${G_λ∣λ∈Λ}$  是$A$的一个开覆盖, 则 $∃ε&gt;0$, 使得$∀x∈A$, 存在$G_x∈G_λ$ 满足$ O(x,ε)⊂G_x$ .</li><li>设$X$是度量空间, $A⊂X$, $A$是紧集当且仅当$A$的任意开覆盖存在有限开覆盖.</li></ul><blockquote><p>  度量空间上的连续映射保持紧性不变的另一种证明方法: </p><p>设 $ {G_λ} $是$f(A)$的一个开覆盖. 因为$f$是连续映射,   以$ f^{−1}(G_λ)$是$A$的一个开覆盖. 由$A$的紧性知, 存在$ f^{−1}(G_i)_{i&#x3D;1}^n$覆盖$A$, 因此${G_λ} _{i&#x3D;1}^n$覆盖$f( A)$.</p><p>$设 X $是紧空间,  $f:X→R  $为连续映射, 则 $f  $为一致连续映射.</p><p>设$ (X,d) $是度量空间, 则$X$为紧空间的充要条件是：对$X$中的任何闭集族  ${F_{\lambda}|\lambda \in \Lambda} $,若其中任意有限个闭集$F_{\lambda}$的交集都为非空集，则 $\cap_{ \lambda \in \Lambda} F_{\lambda}$也必为非空集.  </p></blockquote><p>​<img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-cdc9368fb3282cc1952071757e9b19d1_1440w.png" alt="img"></p><h2 id="度量空间中的紧集"><a href="#度量空间中的紧集" class="headerlink" title="度量空间中的紧集"></a><strong>度量空间中的紧集</strong></h2><h2 id="第一章复习"><a href="#第一章复习" class="headerlink" title="第一章复习"></a><strong>第一章复习</strong></h2><ul><li>概念：</li><li>度量空间，拓扑空间，可分空间，完备空间，紧空间，可分集，完备集，列紧集，紧集，有界集，全有界集，开覆盖</li><li>内点，闭包，领域，开集，闭集，稠密，$\epsilon$网</li><li>连续，一致连续，基本列，子列，收敛列</li></ul><h1 id="线性赋范空间与内积空间"><a href="#线性赋范空间与内积空间" class="headerlink" title="线性赋范空间与内积空间"></a><strong>线性赋范空间与内积空间</strong></h1><h2 id="线性赋范空间的定义及性质"><a href="#线性赋范空间的定义及性质" class="headerlink" title="线性赋范空间的定义及性质"></a><strong>线性赋范空间的定义及性质</strong></h2><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-fe0db10452c9ee6c198bf235454c1954_1440w.png" alt="img"></p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-07ef6c659278e77b608909d3663b43e3_1440w.png" alt="img"></p><h2 id="线性赋范空间的子集和商空间"><a href="#线性赋范空间的子集和商空间" class="headerlink" title="线性赋范空间的子集和商空间"></a>线性赋范空间的子集和商空间</h2><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-433b88f881e2cecedb575209a684147a_1440w.png" alt="img"></p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-1256d38f66ba1eb5dbb6a176133cbf9a_1440w.png" alt="img"></p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-0262f5c2be38547f7b0abcf6c4beb0f4_1440w.png" alt="img"></p><h2 id="线性赋范空间和范数等价"><a href="#线性赋范空间和范数等价" class="headerlink" title="线性赋范空间和范数等价"></a>线性赋范空间和范数等价</h2><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-5abc22fc85cbd1b8128b03919c9f2849_1440w.png" alt="img"></p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-6d9f581fb4c4689238251fdde606d3cb_1440w.png" alt="img"></p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-99a4b6c533add623cda6ace3532dde32_1440w.png" alt="img"></p><h2 id="线性赋范空间的维数与紧性"><a href="#线性赋范空间的维数与紧性" class="headerlink" title="线性赋范空间的维数与紧性"></a>线性赋范空间的维数与紧性</h2><blockquote><p>Resize定理的证明思路很重要</p></blockquote><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-f566e21eb6b918f4e7b66216fa87c86b_1440w.png" alt="img"></p><h2 id="内积空间的定义"><a href="#内积空间的定义" class="headerlink" title="内积空间的定义"></a>内积空间的定义</h2><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-4eb272b29c0b18f1ede0db55b4be1864_1440w.png" alt="img"></p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-11360fe306aeb00d33ce45d28945342b_1440w.png" alt="img"></p><h2 id="内积空间与线性赋范空间的关系"><a href="#内积空间与线性赋范空间的关系" class="headerlink" title="内积空间与线性赋范空间的关系"></a>内积空间与线性赋范空间的关系</h2><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-7419c2b8fbdd954db4f14e83c7a376a5_1440w.png" alt="img"></p><h2 id="内积空间的正交系"><a href="#内积空间的正交系" class="headerlink" title="内积空间的正交系"></a>内积空间的正交系</h2><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-c34cd910fc0faa5a178a2ab702521ed9_1440w.png" alt="img"></p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-e5c06329ef35bffc9c2c3c55a35d0fee_1440w.png" alt="img"></p><h2 id="内积空间正交系"><a href="#内积空间正交系" class="headerlink" title="内积空间正交系"></a>内积空间正交系</h2><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-a35f46bef4ea912b95cec812f820c3e7_1440w.png" alt="img"></p><h2 id="傅里叶级数与收敛性"><a href="#傅里叶级数与收敛性" class="headerlink" title="傅里叶级数与收敛性"></a>傅里叶级数与收敛性</h2><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-c84c2b1b7efbe5bda5bd88e8eefc72c2_1440w.png" alt="img"></p><h1 id="线性算子"><a href="#线性算子" class="headerlink" title="线性算子"></a><strong>线性算子</strong></h1><h2 id="线性算子的定义和性质"><a href="#线性算子的定义和性质" class="headerlink" title="线性算子的定义和性质"></a><strong>线性算子的定义和性质</strong></h2><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-a5117709a5f9e0523dc87e5befd3cc45_1440w.png" alt="img"></p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-c84c2b1b7efbe5bda5bd88e8eefc72c2_1440w-16989345378491.png" alt="img"></p><h2 id="线性算子的零空间"><a href="#线性算子的零空间" class="headerlink" title="线性算子的零空间"></a>线性算子的零空间</h2><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-ad81e05a9b1bc6b50e97d88b63e43096_1440w.png" alt="img"></p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-5da4104109990609d6158c1c03ee006f_1440w.png" alt="img"></p><h2 id="线性有界算子空间"><a href="#线性有界算子空间" class="headerlink" title="线性有界算子空间"></a>线性有界算子空间</h2><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-f158a575b48fe32ffb80808330a1a3f0_1440w.png" alt="img"></p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-8d27303e14726151def5fbe3993b6a1e_1440w.png" alt="img"></p><h2 id="对偶空间与Reisz表示定理"><a href="#对偶空间与Reisz表示定理" class="headerlink" title="对偶空间与Reisz表示定理"></a>对偶空间与Reisz表示定理</h2><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-7bb285bb94d0b3e53e1d984de747930e_1440w.png" alt="img"></p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-dc477b1958f5cd89bae18867027018ad_1440w.png" alt="img"></p><h2 id="算子乘法与逆算子"><a href="#算子乘法与逆算子" class="headerlink" title="算子乘法与逆算子"></a>算子乘法与逆算子</h2><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-d3d258a15e2148da660c8eab7e4e616e_1440w.png" alt="img"></p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-f5fbd84d848c71b35892c26aa1a07994_1440w.png" alt="img"></p><h2 id="Baire纲定理"><a href="#Baire纲定理" class="headerlink" title="Baire纲定理"></a>Baire纲定理</h2><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-10237668b0ea457bd378504375c0321c_1440w.png" alt="img"></p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-eb3560a75ddfc21ed6b64a4eeef514ef_1440w.jpeg" alt="img"></p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-00969702b8ea1c488f6c420dc0e7b927_1440w.png" alt="img"></p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-be9656e1999c53787352eb9c1f4402ca_1440w.png" alt="img"></p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-81bd992362374e8353c0ffe60c3cc4be_1440w.png" alt="img"></p><h2 id="线性泛函的延拓定理"><a href="#线性泛函的延拓定理" class="headerlink" title="线性泛函的延拓定理"></a>线性泛函的延拓定理</h2><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-38e00ad885c93e7a131900215b6afd51_1440w.png" alt="img"></p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-06573f4a69074468a621d55426a354b0_1440w.png" alt="img"></p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-ad83cbff38b44f54f7c368540d56d15a_1440w.png" alt="img"></p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-351b996a7c0b96a2472396b5cc4d9a5c_1440w.jpeg" alt="img"></p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-9ece3776d4893acdbbb3adaf49275781_1440w.png" alt="img"></p><h2 id="闭图像定理"><a href="#闭图像定理" class="headerlink" title="闭图像定理"></a>闭图像定理</h2><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-f24e09ea828ed2fa468f63d97fcc73b2_1440w.png" alt="img"></p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-c14079fa57bc60ea0401fe87ee353565_1440w.png" alt="img"></p><h2 id="一致有界定理"><a href="#一致有界定理" class="headerlink" title="一致有界定理"></a>一致有界定理</h2><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-463f039f6cafabc712a312b393fea755_1440w.png" alt="img"></p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-874bdd1873aeaf9000233c1103146287_1440w.png" alt="img"></p><h1 id="泛函分析应用"><a href="#泛函分析应用" class="headerlink" title="泛函分析应用"></a>泛函分析应用</h1><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-3038f73aede28c77e5b320f61a3addd4_1440w.png" alt="img"></p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-eee4fbddbe944c9fbe8e07a895c0bea4_1440w.png" alt="img"></p><p>💪小知！！！</p><p><img src="/2023/11/02/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/v2-73defcfa0120371d8c6c97efcdb0b11e_b.jpg" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
      <category>大三下专业课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mathematics</tag>
      
      <tag>major subject</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实变函数</title>
    <link href="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/"/>
    <url>/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="实变函数"><a href="#实变函数" class="headerlink" title="实变函数"></a>实变函数</h1><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-24d29c033d9aef226e2085f0dfdc6e96_1440w.webp" alt="小珍珠"></p><span id="more"></span><p>2022&#x2F;10&#x2F;12</p><p>经建议，增加了第一章习题的答案（因为课已经修完了，没有太多时间自己重新写一遍，网上找了下答案，大家方便发一下</p><hr><p>6.24</p><p>今天整理下实变函数整本书的框架！</p><p>这本书我们主要讲了前五章，第六章微分与不定积分略有涉及。</p><hr><p>6.17考完试啦啦啦，这次考试知识点真的好多要背记。所以写了好几页纸，希望能帮助大家，顺便记录一下🐳🐳</p><h2 id="第一章-集合"><a href="#第一章-集合" class="headerlink" title="第一章 集合"></a>第一章 集合</h2><ul><li>1.集合的表示</li><li>2.集合的运算</li><li>3.对等和基数</li><li>4.可数集合</li><li>5.不可数集合</li></ul><h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><p>一、集合的包含关系和并、交、差、补等概念，以及集合的运算律.</p><p>注意对一列集合并与交的概念的理解和掌握. </p><p>二、映射是数学中一个基本概念，要弄清单射、满射和双射之间的区别与联系.</p><p>集合对等的证明:</p><p>1.依对等的定义直接构造两集间的双射</p><p>2.利用对等的传递性，如欲证$A\sim C$，已知$A\sim B$,此时只须证$B\sim C$;</p><p>3.应用有关定理，特别是<strong>伯恩斯坦定理</strong>，它是判断两个集合对等的常用的有效方法.</p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-e1c0c3526aab7bfcd9d335cff52e268b_1440w.png" alt="img"></p><p>三、可数集是无限集合中的最重要的一类集合，它是无限集合中的基数最小者</p><p>注意可数集合的相关运算</p><p>四、连续集及其运算性质，掌握常见的连续集的例子</p><h3 id="主要定理与结论"><a href="#主要定理与结论" class="headerlink" title="主要定理与结论"></a>主要定理与结论</h3><p><strong>1.集合运算法则</strong><br>$$<br>(1) &amp; A \cup B&#x3D;B \cup A, A \cap B&#x3D;B \cap A \<br> (2) &amp; A \cup(B \cup C)&#x3D;(A \cup B) \cup C,(A \cap B) \cap C&#x3D;A \cap(B \cap C) \<br> (3) &amp; A \cap\left(\bigcup_{a \in A}\ B_{a}\right)&#x3D;\bigcup_{a \in A}\left(A \cap B_{a}\right)\<br>  (4) &amp; A \backslash B&#x3D;A \cap B^{c}<br>$$<br><strong>2.德摩根公式</strong><br>$$<br>(1)  \left(\bigcup_{\alpha \in A} A_{\alpha}\right)^{c}&#x3D;\bigcap_{a \in A} A_{\alpha}^{c} \ (2) \left(\bigcap_{\operatorname{\alpha \in A}} A_{\alpha}\right)^{c}&#x3D;\bigcup_{\alpha \in A} A_{\alpha}^{c} .<br>$$</p><p><strong>3.上下极限集合的定义</strong><br>$$<br>(1) \varliminf <em>{n\rightarrow \infty} A</em>{n}&#x3D;\bigcup_{n&#x3D;1}^{\infty} \bigcap_{m&#x3D;n}^{\infty} A_{m} .\ (2)  \varlimsup <em>{n \rightarrow \infty} A</em>{n}&#x3D;\bigcap_{n&#x3D;1}^{\infty} \bigcup_{m&#x3D;n}^{\infty} A_{ m} .<br>$$</p><p> <strong>4.伯恩斯坦定理</strong></p><p>设A,B是两个非空集合，若A对等于B的一个集合，且B有对等于A的一个子集，则A与B对等，即$A\sim B$</p><p><strong>5.并集的基数</strong></p><p><strong>6.直积的基数</strong></p><p><strong>7.幂集的基数</strong></p><p>没有最大基数定理</p><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-b02585ad6f1a0bc85dfa03c8910886c5_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-85ebbfe62b15b0f867b5c30674784571_1440w.jpeg" alt="img"></p><h3 id="重要定理证明"><a href="#重要定理证明" class="headerlink" title="重要定理证明"></a><strong>重要定理证明</strong></h3><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-7dc04f54ff0828dd6685cddecd384f1e_1440w.jpeg" alt="img"></p><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-cddff504bbf983f33f5d1765765e5908_1440w.png" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-3459dc0f823f40c653f1f7702615053a_1440w.png" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-1a99ae605ec23a7ba7a5dc19800b913c_1440w.png" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-5c2448ff5a504fa5be7cc3d6982a8f5b_1440w.png" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-1fd84530d273dd5776fbb38828c01803_1440w.png" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-27c12cb473e7cb6e5fec52a4ff8f7dd5_1440w.png" alt="img"></p><h2 id="第三章-测度论"><a href="#第三章-测度论" class="headerlink" title="第三章 测度论"></a>第三章 测度论</h2><h3 id="主要内容-1"><a href="#主要内容-1" class="headerlink" title="主要内容"></a>主要内容</h3><p>主要讨论R”中点集的测度，它是建立勒贝格积分的基础.</p><p>一、外测度和可测集是本章的两个主要概念，关于可测集的定义，主要使用的是卡氏条件。因为可测集的测度等于其外测度，所以外测度性质对可测集都适用。</p><p>二、可测集的运算性质：可测集类在有限次或可列次并、交、补集运算之下是封闭的。可测集的可列可加性和单调可测集列极限的测度的结果在后面的学习中会时常用到.</p><p>三、关于可测集的构造是本章的一重要内容，勒贝格可测集是由波雷尔集和测度为零的集的全体所构成的可加集族。我们还讨论了勒贝格可测集同开集、闭集、  型集和  型集之间的关系。</p><p><strong>主要定理与结论</strong></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-2388d205acb132a3f2222d27583729d2_1440w.png" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-db410e0201f6e559868f65db59eac116_1440w.png" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-a9ae4d5ce6c273295d370a941df7891e_1440w.png" alt="img"></p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-a745f55e7fdeb3551722e98b840924c7_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-ca36cc9b805aad6204d690fe66a1588d_1440w.jpeg" alt="img"></p><h3 id="重要定理证明-1"><a href="#重要定理证明-1" class="headerlink" title="重要定理证明"></a>重要定理证明</h3><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-1ab262b972a0e9b7fee3a5c53f29ca28_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-a5e91db924272a850b8a80306493ebbd_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-64d92988f4faac902208f73780c87aab_1440w.jpeg" alt="img"></p><h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-cf61b8b22a968e786c47b3320d994cc9_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-4e8ea9c1cf9fb69b18ca5203a196300b_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-b5b79b8d79df163a262003019a0a1e37_1440w.jpeg" alt="img"></p><h2 id="第四章-可测函数"><a href="#第四章-可测函数" class="headerlink" title="第四章 可测函数"></a>第四章 可测函数</h2><p>为了建立勒贝格积分理论的需要，本章讨论一类重要的函数一-可测函数。它一方面和我们熟悉的连续函数有密切的联系，同时又在理论上和应用上成为足够广泛的一类函数.</p><p>一、可测函数的概念及其运算性质是本章的重要内容，可测函数的定义及给出的一些充要条件是判断函数可测的有力工具。</p><p>可测函数关于加、减、乘、除四则运算和极限运算都是封闭的。可测函数上、下确界函数和上、下极限函数还是可测的，所有这些性质反映了可测函数的优越性和应用中的方便之处。</p><p>二、可测函数列的收敛性也是本章的重要内容之一。<strong>几乎处处收敛</strong>和<strong>依测度收敛</strong>是勒贝格积分理论中经常使用的两种收敛形式。</p><p><strong>叶果洛夫定理</strong>揭示了可测函数列几乎处处收敛与准一致收敛之间接关系。通过这个定理，可以把几乎处处收敛的函数列部分地“恢复”一致收敛，而准一致收敛在许多问题的研究中都起着重要作用。</p><p><strong>勒贝格定理</strong>告诉我们：在测度有限的集合上，几乎处处收敛的可测函数列必是依测度收敛的，反之并不成立.然而，<strong>里斯</strong>指出:依测度收敛的可测函数列必有几乎处处收敛的子序列。</p><p>三、<strong>可测函数的构造</strong>是本章的又一重要内容。一般常见的函数，如连续函数，单调函数等都是可测函数.然而，可测函数却未必是连续的，甚至可以是处处不连续的(如迪利克雷函数)。所以，可测函数类比连续函数类要广泛得多。而<strong>鲁金定理</strong>指出了可测函数与连续函数之间的关系，通过这个定理，常常能把可测函数的问题转化为关于连续函数的问题来讨论，从而带来很大的方便。</p><h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-caa14a260ca77afa57104a9d2cac73e3_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-ca0979743a4d788089d6ed0d59310f99_1440w.jpeg" alt="img"></p><h3 id="重要定理证明-2"><a href="#重要定理证明-2" class="headerlink" title="重要定理证明"></a>重要定理证明</h3><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-781e7d1501f56238a62659ebcd2dffb3_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-50fea0f94b95fcae9e6522372122f043_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-85b706e35b0404bb6389424fdbfa7a0c_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-73a7f3f0761b69cc3eb3784b19501c39_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-aa2e5ed95cff7ea82cee33ae75ad8656_1440w.jpeg" alt="img"></p><h3 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h3><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-b7b4581e0e2447f1e6186b9b254df2bc_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-871e3bd321a80da4ec0fd7667ae717ab_1440w.jpeg" alt="img"></p><h2 id="第四章-勒贝格积分"><a href="#第四章-勒贝格积分" class="headerlink" title="第四章 勒贝格积分"></a>第四章 勒贝格积分</h2><p>主要内容</p><p>本章的中心内容是建立一种新的积分——勒贝格积分理论.它也是实变函数数论研究的中心内容.</p><p>一、关于勒贝格积分的建立.</p><p>第一步是建立非负简单函数的积分，利用简单函数逼近非负可测函数，第二步我们建立非负可测函数的积分，第三步是建立一般函数的积分，它是将其分解两个非负函数(正部与负部)的差的办法来完成的。</p><p>二、勒贝格积分的性质</p><p>1）勒贝格是一种<strong>绝对收敛积分</strong>，这是它与黎曼积分的重要区别之一</p><p>2）<strong>绝对连续性</strong></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-c35d08ebbf7f07bd93c4215bb76125fc_1440w.png" alt="img"></p><p>三、积分极限定理</p><p><strong>1）莱维定理</strong></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-8f2df464abc30ae57b1f4da743bf66df_1440w.png" alt="img"></p><p><strong>2）逐项积分定理</strong></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-aee518549246112be61ba34568e6a23e_1440w.png" alt="img"></p><p><strong>3）法图引理</strong></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-2100f9728f02f247dc45b634e44741b7_1440w.png" alt="img"></p><p><strong>4）勒贝格控制收敛定理</strong></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-2aaef775389b16200bcaf172b24eb00e_1440w.png" alt="img"></p><p><strong>5）单调收敛定理</strong></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-7fea73d1ff919bc9440145879009e1b1_1440w.png" alt="img"></p><p>可以看出，与黎曼积分相比较，勒贝格积分与极限换序的条件大大减弱，这也是勒贝格积分优越于黎曼积分的重要之处。</p><p>四、关于勒贝格积分与黎曼积分之间的关系</p><p><strong>黎曼可积</strong>的充要条件</p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-9f63d0c4a0cb1c4c0b11310f2ca9961e_1440w.png" alt="img"></p><p>关于勒贝格积分的计算，一般应用积分的定义借助于积分的性质将其转化为黎曼积分</p><p>五、勒贝格重积分换序</p><p><strong>富比尼定理</strong></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-4475f9a77461059e700174b858609fbd_1440w.png" alt="img"></p><h3 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h3><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-ae552d5cc1223c24a19d6668276c4833_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-93c368dd35988296de57e37cafda7a55_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-1df91f44ec6ce3e7350d970eac41763d_1440w.jpeg" alt="img"></p><h3 id="重要定理证明-3"><a href="#重要定理证明-3" class="headerlink" title="重要定理证明"></a>重要定理证明</h3><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-1a062fe4b4ccb06a2c5852eed0ae686a_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-8e803f6b991dd4f67097ee82cba4d949_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-f2cdda3239bdf7bd846cf3ee364f022a_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-a13bfaa6707c26abdb547a110d4e6af3_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-00825db9953fb640c4ec7dc947d06b05_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-1c3a623ffd257ddc136f528c573c8627_1440w.jpeg" alt="img"></p><h2 id="第六章-积分论"><a href="#第六章-积分论" class="headerlink" title="第六章 积分论"></a>第六章 积分论</h2><p>第六章由于时间关系，我们只讲了一点点内容</p><p>主要有<strong>有界变差函数</strong>和<strong>绝对收敛函数</strong>的相关性质</p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-3b5cf9b1496114c991bff6458657dabb_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-b94cab32dff2aa91155b10272ea9ec5a_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-7eb9bc4e94985d27922c7fe859224ce6_1440w.jpeg" alt="img"></p><hr><p>下一个学期泛函分析加油！数学系的人er冲冲冲</p><p>See you last time!!!</p><p><img src="/2023/10/31/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/v2-4492929c96dd9684775fa9feb0cbb621_1440w.webp" alt="salute"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>实变函数与泛函分析基础 课后习题答案详解解析<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:1" class="footnote-text"><span><a href="https://www.wenke99.com/p-6696916.html">https://www.wenke99.com/p-6696916.html</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
      <category>大二下专业课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mathematics</tag>
      
      <tag>major subject</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>空间解析几何</title>
    <link href="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/"/>
    <url>/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/</url>
    
    <content type="html"><![CDATA[<p>空间解析几何知识点复习&amp;思维导图</p><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/%E5%B0%8F%E7%86%8A%E7%8C%AB.jpg" alt="img"></p><span id="more"></span><p>这是这本书的框架</p><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-6f44e0913decc4fb0260be8154db71d3_1440w.png" alt="img"></p><h2 id="chapter1-向量与坐标"><a href="#chapter1-向量与坐标" class="headerlink" title="chapter1 向量与坐标"></a>chapter1 向量与坐标</h2><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-24779cbf03dfb340582d245205c36a48_1440w.png" alt="img"></p><h3 id="笔记-知识点"><a href="#笔记-知识点" class="headerlink" title="笔记&amp;知识点"></a>笔记&amp;知识点</h3><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-52d12f1ec8b07e88d966aa57aa5f5142_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-ffa0feb4a5833622cf581c354326fe4f_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-5a6fd02c97b1ff63a9c24ac10c96a896_1440w.jpeg" alt="img"></p><p> <img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-308ee81c1ce4bd99fdedeaccd052c7e1_1440w.jpeg" alt="img"></p><h2 id="chapter-2-轨迹与方程"><a href="#chapter-2-轨迹与方程" class="headerlink" title="chapter 2 轨迹与方程"></a>chapter 2 轨迹与方程</h2><h3 id="思维导图-1"><a href="#思维导图-1" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-a9525215a4b8bfc917e2f9230773a898_1440w.png" alt="img"></p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-bcdf95f4b0f79d1d7ae902a5dfd7cf41_1440w.jpeg" alt="img"></p><h2 id="chapter-3-空间的平面与直线"><a href="#chapter-3-空间的平面与直线" class="headerlink" title="chapter 3 空间的平面与直线"></a>chapter 3 空间的平面与直线</h2><h3 id="思维导图-2"><a href="#思维导图-2" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-f8f019a2ddcb66284288a3c250539486_1440w.png" alt="img"></p><h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-774c47793e9bc14c93f19766890eaa79_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-722c413e188e344e7a6cc7b458c8fc04_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-d1950ac8d9fd60ae56c9e7b21da0360b_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-2fc32035bea6df43b94ce488f1cdde33_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-6887bc9c47a2ab6405d946ed389f72a3_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-757b2c760f9b45f59ac9ef7f76f091b3_1440w.jpeg" alt="img"></p><h2 id="chapter-4-柱面、锥面、旋转曲面与二次曲面"><a href="#chapter-4-柱面、锥面、旋转曲面与二次曲面" class="headerlink" title="chapter 4 柱面、锥面、旋转曲面与二次曲面"></a>chapter 4 柱面、锥面、旋转曲面与二次曲面</h2><h3 id="思维导图-3"><a href="#思维导图-3" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-8fc38194c2f782174eb586e4efbef496_1440w.png" alt="img"></p><h3 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h3><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-791c8ff7354a1ec38e0e0f82ceff0b33_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-ddf9ba0262563c597fc2b577a54a2f12_1440w.jpeg" alt="img"></p><p> <img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-968aa99467f5567986ef22e5bdc6f0d7_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-06fa703b85b9652bb5718b8349f72765_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-786d4f0a83292874c033d0aae08a05bf_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-b0d17801413cea99dd8a2cb9aca6c3ae_1440w.jpeg" alt="img"></p><h2 id="chapter-5-二次曲线的一般结论"><a href="#chapter-5-二次曲线的一般结论" class="headerlink" title="chapter 5 二次曲线的一般结论"></a>chapter 5 二次曲线的一般结论</h2><h3 id="思维导图-4"><a href="#思维导图-4" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-8926a8031a425b852af3f24194c3368d_1440w.png" alt="img"></p><h3 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h3><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-381da9dafbf5eb8084d470c301bee495_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-fdfee72ff80f40793221c3136c472cf2_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-2823796a72f557cc3b85646a9e07e15f_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-4b67a895f6de27b2497aa2d0c1f75b51_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-e5990da2b5bdd417750b4a2f815cfce5_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-6f7bbcf5acf59294ebc638d2b509e0a8_1440w.jpeg" alt="img"></p><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/v2-656b4d47efbad781ae99caa401fd0d2c_1440w.jpeg" alt="img"></p><p>over!!!</p><p><img src="/2023/10/31/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/%E4%B9%88%E4%B9%88.jpg" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
      <category>大一上专业课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mathematics</tag>
      
      <tag>major subject</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性控制理论</title>
    <link href="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/"/>
    <url>/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="线性控制理论-自动控制原理期末知识点总复习"><a href="#线性控制理论-自动控制原理期末知识点总复习" class="headerlink" title="线性控制理论&#x2F;自动控制原理期末知识点总复习"></a>线性控制理论&#x2F;自动控制原理期末知识点总复习</h1><span id="more"></span><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li>经典控制理论</li><li>数学模型：线性定常高阶微分方程和传递函数</li><li>分析方法：时域，根轨迹法，频域法</li><li>单输入单输出</li><li>现代控制理论</li><li>数学模型：以一阶微分方程组成的差分方程组表示的动态方程</li><li>分析方法：精准的时域分析法</li><li>多输入多输出，非线性系统，时变系统</li></ul><p><strong>拉式变换</strong></p><ul><li>$F(s)&#x3D;\mathcal{L}(f(t))&#x3D;\int_0^{\infty} f(t)e^{-st}dt $</li><li>常见例子：</li></ul><p>$$<br>\mathcal{L}[1]&#x3D;\dfrac{1}{s}，\mathcal{L}[t]&#x3D;\dfrac{1}{s^2}，\mathcal{L}[e^{at}]&#x3D;\dfrac{1}{s-a}<br>$$</p><p>$$<br>\mathcal{L}[sinwt]&#x3D;\dfrac{w}{s^2+w^2}，\mathcal{L}[coswt]&#x3D;\dfrac{s}{s^2+w^2}<br>$$</p><ul><li><p>基本性质：</p><ol><li><p>线性性质：$\mathcal{L}[af_1+bf_2]&#x3D;a\mathcal{L}[ f_1]+b\mathcal{L}[f_2]$</p></li><li><p>微分方程：</p><p>$\mathcal{L}[\dfrac{df(t)}{dt}]&#x3D;sF(s)-f(0)$,</p><p>$\mathcal{L}[\dfrac{d^nf(t)}{dt^n}]&#x3D;s^nF(s)-s^{n-1}f(0)-\cdots-f^{(n-1)}(0)$</p></li><li><p>积分定理：</p><p>$\mathcal{L}[\int_0^{\infty}f(\eta)d\eta]&#x3D;\dfrac{F(s)}{s}$</p><p>$\mathcal{L}[\int_0^{\infty}\cdots \int_0^{\infty} f(\eta)d\eta\cdots d\eta]&#x3D;\dfrac{F(s)}{s^n}$</p></li><li><p>初值定理：$\lim\limits_{s\rightarrow \infty}sF(s)&#x3D;f(0^+)$</p></li><li><p>终值定理：$\lim\limits_{s\rightarrow 0}sF(s)&#x3D;f(+\infty)$</p></li></ol></li></ul><p>&#x3D;&#x3D;<strong>求逆变换</strong>&#x3D;&#x3D;</p><ol><li>部分分式的方法：利用常见例子的逆变换的组合</li><li>留数定理</li></ol><p>  <img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-c189f10dbab1b164af49bde1fdd3a390_1440w.png" alt="img"></p><h3 id="⭐考点"><a href="#⭐考点" class="headerlink" title="⭐考点:"></a>⭐考点:</h3><ul><li><p>求$F(s)&#x3D;\dfrac{s}{s^2+1}$的逆变换<br>$$<br>B(s)&#x3D;s^2+1,s_1&#x3D;j,s_2&#x3D;-j<br>$$</p><p>$$<br>f(t)&#x3D;\dfrac{s}{2s}e^{st}|<em>{s&#x3D;j}+\dfrac{s}{2s}e^{st}|</em>{s&#x3D;-j}&#x3D;cost,(t&gt;0)<br>$$</p></li><li><p>求$F(s)&#x3D;\dfrac{1}{s(s-1)^2}$的逆变换<br>$$<br>B(s)&#x3D;s(s-1)^2,s&#x3D;0,单零点,s&#x3D;1,2<br>$$</p><p>$$<br>\begin{split}<br>f(t)&#x3D;&amp;\dfrac{1}{3s^2-4s+1}e^{st}|<em>{s&#x3D;0}+\lim\limits</em>{s\rightarrow 1}\dfrac{d}{ds}\left[(s-1)^2\dfrac{1}{s(s-1)^2}e^{st}\right]_{s&#x3D;-j}\&#x3D;&amp;1+e^t(t-1),(t&gt;0)<br>\end{split}<br>$$</p></li><li><p>求$F(s)&#x3D;\dfrac{1}{s^2(s+1)}$的逆变换<br>$$<br> F(s)&#x3D;\dfrac{-1}{s}+\dfrac{1}{s^2}+\dfrac{1}{s+1}<br>$$<br>$$<br>f(t)&#x3D;\mathcal{L}^{-1}[\dfrac{1}{s^2(s+1)}]&#x3D;-1+t+e^{-t}<br>$$</p></li></ul><h2 id="动态系统的状态空间描述"><a href="#动态系统的状态空间描述" class="headerlink" title="动态系统的状态空间描述"></a>动态系统的状态空间描述</h2><h3 id="系统模型的建立"><a href="#系统模型的建立" class="headerlink" title="系统模型的建立"></a>系统模型的建立</h3><ul><li>基本概念</li></ul><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-766f4412dfedda32f92cb16ba3420dcd_1440w.png" alt="img"></p><ul><li>两类动态模型的定义</li></ul><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-8aa3796f00e5216420609d33f0923c71_1440w.png" alt="img"></p><ul><li>传递函数</li></ul><p><strong>零初始条件</strong>下$G(s)&#x3D;\dfrac{F(y(t))}{F(u(t))}&#x3D;\dfrac{y(s)}{u(s)}$  </p><p>零初始条件：$t\leq0$时，输入$u(t)$，输出$y(t)$，它们各阶导$&#x3D;0$。</p><ol><li>单输入单输出的<strong>传递函数</strong></li></ol><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-143ddc5b725523e83cd86d20c23c3de8_1440w.png" alt="img"></p><ol start="2"><li>多输入多输出的传递函数矩阵</li></ol><p> <img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-3a7ed11c878a54af7823549dabf5ebe5_1440w.png" alt="img"></p><p>$$<br>\lim\limits_{s\rightarrow \infty}G(s)&#x3D;D&#x3D;\begin{cases}\neq 0, ,G(s)真\<br>&#x3D;0,,G(s)严格真\end{cases}<br>$$</p><ul><li>动态系统的分类</li></ul><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-a7dd3156a82b17b45bb1b93c82d901ab_1440w-16984808949627.png" alt="img"></p><h3 id="⭐单输入单输出的I-O模型与SS模型"><a href="#⭐单输入单输出的I-O模型与SS模型" class="headerlink" title="⭐单输入单输出的I&#x2F;O模型与SS模型"></a>⭐单输入单输出的I&#x2F;O模型与SS模型</h3><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-d65dbccf57ade6c51662e44eb9a1c834_1440w-169848091420910.png" alt="img"></p><h3 id="⭐多输入多输出的I-O模型与TF模型"><a href="#⭐多输入多输出的I-O模型与TF模型" class="headerlink" title="⭐多输入多输出的I&#x2F;O模型与TF模型"></a>⭐多输入多输出的I&#x2F;O模型与TF模型</h3><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-6d1fcb3912ef1ab2f6e40c9a673fe006_1440w.png" alt="img"><br>$$<br>\begin{split}G(s)&#x3D;&amp;\dfrac{P(s)}{d(s)}&#x3D;\dfrac{1}{d(s)}(P_{k-1}s^{k-1}+\cdots+P_1s+P_0),P_m是q\times p常矩阵\ d(s)&#x3D;&amp;s^k+\alpha_{k-1}s^{k-1}+\cdots+\alpha_0\end{split}<br>$$</p><h3 id="线性系统规范型状态方程"><a href="#线性系统规范型状态方程" class="headerlink" title="线性系统规范型状态方程"></a>线性系统规范型状态方程</h3><ul><li><p>对角规范型</p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-115bf2391b72892fd0361b04cf19d5d2_1440w.png" alt="img"></p></li><li><p>Jordan规范型</p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-86ae2ea76b58eb9f4b1e91ac4b3b3b40_1440w.png" alt="img"></p></li></ul><h3 id="代数等价线性系统的不变性"><a href="#代数等价线性系统的不变性" class="headerlink" title="代数等价线性系统的不变性"></a>代数等价线性系统的不变性</h3><ul><li><p>状态空间的坐标变换【系数矩阵的转置】</p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-8ba671be8a73d1cc4a90b36b24c94be0_1440w.png" alt="img"></p></li><li><p>不变性</p><p>$\bar{x}&#x3D;Px$</p><p>$\overline{A}&#x3D;PAP^{-1},\overline{B}&#x3D;PB,\overline{C}&#x3D;CP^{-1},\overline{D}&#x3D;D$</p><p>特征值相同， $G(s)$不变</p></li></ul><h3 id="组合系统的状态空间模型和传递函数"><a href="#组合系统的状态空间模型和传递函数" class="headerlink" title="组合系统的状态空间模型和传递函数"></a>组合系统的状态空间模型和传递函数</h3><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-fca529c1ff490e7c9e666dd8689daada_1440w.png" alt="img"></p><h3 id="考点："><a href="#考点：" class="headerlink" title="考点："></a>考点：</h3><ul><li><em>系统方框图</em></li></ul><ol><li><p>化方块图为规范化方框图（原则：当且仅当各组成环节的传递函数均为一阶惯性环节 1&#x2F;(s+si) 和比例放大环节 k ）</p></li><li><p>指定状态向量组（原则是当且仅当一阶惯性环节的输出有资格选为状态变量）</p></li></ol><p>  <img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-cafef30060640bc580a46cbc24664b9f_1440w.png" alt="img"></p><ol start="3"><li>列变量间关系方程（围绕一阶惯性环节和求和环节）</li></ol><p>  <img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-3318d03d3004b80c46ffc7fa44147d6e_1440w.png" alt="img"></p><ol start="4"><li>导出变化域状态变量方程和输出变量方程</li></ol><p>  <img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-e19e298618a83777d31e9046ea9548c7_1440w.png" alt="img"></p><ol start="5"><li>导出状态空间描述（$\dfrac{dx_i}{dt}替代sx_i,用时域变量代替Laplace变量$  ）</li></ol><p>  <img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-8252fa4f996162c8a344f6d72810ffc8_1440w.png" alt="img"></p><p>  <img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-d6df4831974f46f8576fa675e8437815_1440w.png" alt="img"></p><p>简便方法：1&#x2F;s等价于积分，进$\dot{x}$出$x$  </p><ul><li><p><em>考点二：模型转换</em></p></li><li><p><em>考点三：规范型</em></p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-dc4cb6c091c4cd0dcc9a1fc7c00e7be6_1440w.png" alt="img"></p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-0150ad9d185a06ca0e5c56bf183852fd_1440w-169848130261024.png" alt="img"></p></li></ul><h2 id="线性系统的定量分析"><a href="#线性系统的定量分析" class="headerlink" title="线性系统的定量分析"></a>线性系统的定量分析</h2><h3 id="单变量的时域分析"><a href="#单变量的时域分析" class="headerlink" title="单变量的时域分析"></a>单变量的时域分析</h3><ul><li><p>典型输入信号</p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-e43cb7607db9207b08c01f10a079b1b6_1440w.png" alt="img"></p></li><li><p>动态性能与稳态指标</p></li></ul><ol><li><p>单位阶跃响应：系统在单位阶跃作用下的时间响应</p></li><li><p>动态性能指标</p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-9e35fbe0c990a5e1efb97bd2c4824499_1440w.png" alt="img"></p></li><li><p>稳态性能指标</p><p>稳态误差：$e(t)&#x3D;e_{st}(t)+e_{ss}(t),,(e_{st}(t)$调节误差趋于0)</p></li></ol><p><strong>输入误差Vs输出误差</strong></p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-ba490973c60d0e983b5c82b74bc6fd65_1440w.png" alt="img"> </p><p>$$<br>e_{ss}&#x3D;\lim\limits_{t\rightarrow \infty}\mathcal{L}^{-1}(E(s))&#x3D;\lim\limits_{t\rightarrow \infty}\mathcal{L}^{-1}(R (s)&#x2F;(1+G(s)H(s))<br>$$<br><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-c61bc3d09bda2cec870173bdf08f7034_1440w.png" alt="img"></p><p>解析性：对于多项式而言，分母不为0</p><ul><li>系统类型及误差特性</li></ul><p>1.线性定常开环系统的传递函数</p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-6709e6a4b1bb15d627ac5c3da09d4d15_1440w.png" alt="img" style="zoom:150%;"> $$G(s)H(s)=\dfrac{k(1+\tau_1s)\cdots(1+\tau_ns)}{s^v(1+\tau_1s)\cdots(1+\tau_{n-v}s)}=\dfrac{kG_0H_0}{s^v}$$<p>$$<br>e_{ss}&#x3D;\lim\limits_{s\rightarrow 0}sE(s)&#x3D;\lim\limits_{s\rightarrow 0}\dfrac{sR(s)}{1+GH}&#x3D;\lim\limits_{s\rightarrow 0}\dfrac{s^{v+1}R(s)}{s^v+kG_0(s)H_0(s)}<br>$$</p><p><strong>静差：系统在阶跃输入作用下的稳态误差</strong></p><p>2.含外部干扰的单位反馈系统</p><p>  <img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-ef10452f82d7cb5ec8762974743f5d92_1440w.png" alt="img"> </p><p>$$<br>e_{ss}&#x3D;\lim\limits_{s\rightarrow 0}\dfrac{s^{v+1}R(s)}{s^v+kG_0(s)H_0(s)}<br>$$</p><p>  <img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-7f8e587eaa416e5b16e1f5ac2c8cd071_1440w.png" alt="img"></p><p>  $\mathcal{L}(t^n)&#x3D;n!\mathcal{L}(\int_0^t\cdots\int_0^t 1dt\cdots dt)&#x3D;n!\dfrac{\mathcal{L}(1)}{s^n}&#x3D;n!\dfrac{1}{s^{n+1}}$</p><p>  <img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-03a8310cc796d36849f4f66b7c40f094_1440w.png" alt="img"></p><p>例题：</p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-fedf3f415f624b541a3411f4f1bdfe83_1440w-169848154059935.png" alt="img"></p><h3 id="频率响应分析法"><a href="#频率响应分析法" class="headerlink" title="频率响应分析法"></a>频率响应分析法</h3><ul><li><p>BIBO稳定：初始条件为0的单变量LTI系统，若对有界的输入，其输出有界</p></li><li><p>引理：</p><p> $初始条件为0的单变量LTI系统BIBO稳定\ \Leftrightarrow g(s)所有极点具有负实部\ \Leftrightarrow 单位响应函数h(t)绝对可积，\exists k&gt;0 ,\int_0^{\infty}|h(t)|dt&lt;k$</p></li></ul><h3 id="线性系统状态方程解的结构与性质"><a href="#线性系统状态方程解的结构与性质" class="headerlink" title="线性系统状态方程解的结构与性质"></a>线性系统状态方程解的结构与性质</h3><ul><li><p>解的存在唯一性</p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-23803831ca1e906735a74935a4e9ddac_1440w.png" alt="img"></p></li><li><p>解的结构</p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-4e4b17db132c6a49bb3063e1e32146bb_1440w.png" alt="img"></p></li><li><p>零输入响应</p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-156ee7b67ef8d7a1774161fb0f11dc23_1440w.png" alt="img"></p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-0dcb188d35990785b09304fbef58288a_1440w.png" alt="img"></p></li><li><p>零状态响应</p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-4f4a8398b5c72ffbc0c07e78d8721145_1440w.png" alt="img"></p></li></ul><h3 id="线性定常系统的状态转移矩阵和脉冲响应矩阵"><a href="#线性定常系统的状态转移矩阵和脉冲响应矩阵" class="headerlink" title="线性定常系统的状态转移矩阵和脉冲响应矩阵"></a><strong>线性定常系统的状态转移矩阵和脉冲响应矩阵</strong></h3><ul><li><p><strong>状态转移矩阵</strong></p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-ba5b6b9b72bc32b4f72422474d69d82c_1440w.png" alt="img"></p></li><li><p><strong>脉冲响应矩阵</strong></p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-6fe6875dc9d0d2a83c8733c17ae028ec_1440w.png" alt="img"></p></li><li><p><strong>两者关系</strong></p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-18fad039b85645d113804975b5a40bb9_1440w.png" alt="img"></p></li></ul><h2 id="线性系统的能控性和能观测性"><a href="#线性系统的能控性和能观测性" class="headerlink" title="线性系统的能控性和能观测性"></a>线性系统的能控性和能观测性</h2><h3 id="能控性定义和判据"><a href="#能控性定义和判据" class="headerlink" title="能控性定义和判据"></a>能控性定义和判据</h3><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-d2f04017b0089bfd9e5fce62aa6707f4_1440w.png" alt="img"></p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-ab32aa2d2edb474a0d5463dedf796ec7_1440w.png" alt="img"></p><h2 id="能控性常数和指标"><a href="#能控性常数和指标" class="headerlink" title="能控性常数和指标"></a>能控性常数和指标</h2><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-01116275e1b271e8228f2f3024bbb785_1440w.png" alt="img"></p><h3 id="能观测性定义及其判据"><a href="#能观测性定义及其判据" class="headerlink" title="能观测性定义及其判据"></a><strong>能观测性定义及其判据</strong></h3><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-6c5a23c9a866097b6c4c4d81e2b4c091_1440w.png" alt="img"></p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-0965cf49adc191aef0379d469c313490_1440w.png" alt="img"></p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-2952d5677577fd80937082999828ee91_1440w.png" alt="img"></p><h3 id="对偶性原理"><a href="#对偶性原理" class="headerlink" title="对偶性原理"></a><strong>对偶性原理</strong></h3><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-9f5155d12e5f1d2b59a97c67ab1ab1c5_1440w.png" alt="img"></p><h3 id="能控性规范型和能观测规范型"><a href="#能控性规范型和能观测规范型" class="headerlink" title="能控性规范型和能观测规范型"></a><strong>能控性规范型和能观测规范型</strong></h3><p><strong>能控性规范型</strong></p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-797adc7b91c99997d207e0ad3c768db7_1440w.png" alt="img"></p><p><strong>能观测规范型</strong></p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-bc9584d140831e93f8f2401502ba3783_1440w-169848188219254.png" alt="img"></p><blockquote><p>还有MIMO的规范型</p></blockquote><h3 id="线性系统的结构分解"><a href="#线性系统的结构分解" class="headerlink" title="线性系统的结构分解"></a><strong>线性系统的结构分解</strong></h3><p><strong>能控性分解</strong></p><blockquote><p><strong>一部分来自$Q_c$ 一部分来自$R^n$</strong></p></blockquote><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-8f97c40b61a05d8986ccde4ee0d41fc0_1440w.png" alt="img"></p><p>能观测性分解</p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-51f5f6fb9f7593c7b52113492c1fa643_1440w.png" alt="img"></p><p>规范分解</p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-6e69f4eb3157288101448e41114d8bfa_1440w-169848192266159.png" alt="img"></p><h2 id="动态系统的稳定性"><a href="#动态系统的稳定性" class="headerlink" title="动态系统的稳定性"></a>动态系统的稳定性</h2><h3 id="外部稳定性和内部稳定性"><a href="#外部稳定性和内部稳定性" class="headerlink" title="外部稳定性和内部稳定性"></a><strong>外部稳定性和内部稳定性</strong></h3><ul><li><p><strong>BIBO&#x2F;外部稳定</strong></p></li><li><p><strong>内部稳定&#x2F;内部稳定</strong></p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-efe23bf656279b0796edaa3a3c97b0d8_1440w.png" alt="img"></p></li></ul><p><strong>Lyapunov 稳定性</strong></p><ul><li><p><strong>Lyapunov第二方法</strong></p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-39da705064d2c66d8e414616141020e8_1440w.png" alt="img"></p></li></ul><blockquote><p>定常系统：</p></blockquote><p>  <img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-6bc220a1bc4a896b2d2493c0f7b46c65_1440w.png" alt="img"></p><h3 id="线性系统稳定性判据"><a href="#线性系统稳定性判据" class="headerlink" title="线性系统稳定性判据"></a>线性系统稳定性判据</h3><ul><li><p>特征值判据</p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-cb7755e4d505c6b865b2a004279331fe_1440w.png" alt="img"></p></li><li><p>Lyapunov判据</p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-34381a8f9e9749f533cd78da4a37696a_1440w.png" alt="img"></p></li></ul><h2 id="线性反馈系统的时间域综合"><a href="#线性反馈系统的时间域综合" class="headerlink" title="线性反馈系统的时间域综合"></a>线性反馈系统的时间域综合</h2><h3 id="综合问题的提法、类型和性质"><a href="#综合问题的提法、类型和性质" class="headerlink" title="综合问题的提法、类型和性质"></a>综合问题的提法、类型和性质</h3><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-5264c02d609d67687572618dc46fc435_1440w.png" alt="img"></p><ul><li><p>类型</p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-b090b8fd5af5519c33beb3c82ec8ec93_1440w.png" alt="img"></p></li><li><p>状态反馈和输出反馈</p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-f35a6f64be9d9bc1ef546ca0a2198ea8_1440w.png" alt="img"></p></li></ul><h3 id="极点配置"><a href="#极点配置" class="headerlink" title="极点配置"></a>极点配置</h3><ul><li><p>问题</p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-e5592d8f1b8e8e18064cbae05a8b46f4_1440w.png" alt="img"></p></li><li><p>条件</p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-f1dca872799e2f30a654d07054090465_1440w.png" alt="img"></p></li><li><p>极点配置算法</p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-7142a7bad06430a3db04dca0ce05ec03_1440w.png" alt="img"></p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-11c95d359be01d036c56d72bdf220a14_1440w.png" alt="img"></p></li><li><p>可正定条件</p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-9841bc6db90f9cfcd3c3778ad03007a5_1440w.png" alt="img"></p></li></ul><h3 id="状态重构问题和状态观测器"><a href="#状态重构问题和状态观测器" class="headerlink" title="状态重构问题和状态观测器"></a>状态重构问题和状态观测器</h3><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-53871334aeebf3e27c977baf84dc4ade_1440w.png" alt="img"></p><p>观测器按功能分为状态观测器和函数观测器</p><p>观测器按结构分为全维观测器和降维观测器</p><ul><li><p>全维观测器</p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-283399e626cb07fa7de1348015d96367_1440w.png" alt="img"></p></li><li><p>降维观测器</p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-36b5800a5c07d48e595e814cbd3cf6f3_1440w.png" alt="img"></p><p><img src="/2023/10/28/%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/v2-3eadf49c5590b51d912ba06a815b7f5a_1440w.png" alt="img"></p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>《线性系统理论（第二版》郑大钟 清华大学出版社<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
      <category>大三下专业课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mathematics</tag>
      
      <tag>major subject</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇文章呀！</title>
    <link href="/2023/10/28/article-title/"/>
    <url>/2023/10/28/article-title/</url>
    
    <content type="html"><![CDATA[<p><img src="/2023/10/28/article-title/%E5%B0%8F%E9%9D%92%E8%9B%99.jpg" alt="小青蛙">正文的一部分作为摘要</p><span id="more"></span><p>余下的正文</p><div class="note note-success">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><span class="label label-primary">text</span><div>            <input type="checkbox" disabled>普通示例          </div><div>            <input type="checkbox" disabled checked="checked">默认选中          </div>            <input type="checkbox" disabled>内联示例           后面文字不换行<input type="checkbox" disabled> 也可以只传入一个参数，文字写在后边（这样不支持外联）<a class="btn" href="url" title="title" target="_blank">text</a><p>$$<br>E&#x3D;mc^2<br>$$</p><a href="https://akilar.top/posts/615e2dec/," title="&#x2F;img&#x2F;top-img&#x2F;lover.jpg" target>糖果屋教程贴,</a><div><div class="fold_hider"><div class="close hider_title">info @title<p></p></div></div><div class="fold"><p>需要折叠的一段内容，支持 markdown</p></div></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>参考资料1<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>参考资料2<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>个人博客</category>
      
      <category>Hexo博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇文章</title>
    <link href="/2023/10/23/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <url>/2023/10/23/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>个人博客</category>
      
      <category>Hexo博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
